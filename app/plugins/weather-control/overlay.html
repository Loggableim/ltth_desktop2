<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Control Overlay - TikTok Stream Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            background: transparent !important;
            background-color: transparent !important;
        }

        body {
            background: transparent !important;
            background-color: transparent !important;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #weather-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background: transparent !important;
            background-color: transparent !important;
            /* Force GPU rendering */
            will-change: transform;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            background: transparent !important;
            background-color: transparent !important;
            /* Force GPU rendering for canvas */
            will-change: transform;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
        }

        /* Debug overlay */
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            display: none;
            z-index: 10000;
            max-width: 350px;
            border: 2px solid rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }

        #debug-info.active {
            display: block;
        }

        #debug-info .status {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        #debug-info .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        #debug-info .status-dot.connected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        #debug-info .status-dot.disconnected {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Lightning flash overlay */
        #lightning-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9998;
        }

        /* Connection status indicator */
        #connection-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
            display: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #connection-status.show {
            display: block;
            opacity: 1;
        }

        #connection-status.connected {
            background: rgba(0, 128, 0, 0.8);
        }

        #connection-status.disconnected {
            background: rgba(255, 0, 0, 0.8);
        }

        #connection-status.reconnecting {
            background: rgba(255, 165, 0, 0.8);
        }
    </style>
</head>
<body>
    <div id="weather-container">
        <canvas id="weather-canvas"></canvas>
    </div>
    <div id="lightning-flash"></div>
    <div id="debug-info"></div>
    <div id="connection-status"></div>

    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- GSAP for smooth animations (served from local node_modules) -->
    <script src="/gsap/gsap.min.js"></script>

    <!-- Weather Engine -->
    <script>
        /**
         * Weather Control Engine - Modernized
         * 
         * GPU-accelerated weather effects with GSAP animations
         * Supports: rain, snow, storm, fog, thunder, sunbeam, glitchclouds
         */

        // Check if GSAP is loaded
        if (typeof gsap === 'undefined') {
            console.error('‚ùå GSAP library failed to load! Animations will not work.');
            console.error('Please ensure /gsap/gsap.min.js is accessible.');
            log('‚ùå GSAP library failed to load! Animations will be limited.');
            // Show error message on screen using safe DOM manipulation
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,0,0,0.9);color:white;padding:20px;border-radius:10px;font-family:monospace;text-align:center;z-index:99999;';
            const title = document.createElement('strong');
            title.textContent = '‚ö†Ô∏è GSAP Loading Error';
            errorDiv.appendChild(title);
            errorDiv.appendChild(document.createElement('br'));
            const msg1 = document.createTextNode('The GSAP animation library failed to load.');
            errorDiv.appendChild(msg1);
            errorDiv.appendChild(document.createElement('br'));
            const msg2 = document.createTextNode('Weather effects will not display.');
            errorDiv.appendChild(msg2);
            document.body.appendChild(errorDiv);
        } else {
            log('‚úÖ GSAP library loaded successfully');
            log(`GSAP version: ${gsap.version || 'unknown'}`);
        }

        // Configuration
        const config = {
            debug: new URLSearchParams(window.location.search).get('debug') === 'true',
            maxParticles: 500,
            fpsCap: 60,
            showConnectionStatus: true,
            reconnectDelay: 1000,
            reconnectMaxDelay: 30000,
            reconnectBackoffMultiplier: 1.5
        };

        // DOM elements
        const canvas = document.getElementById('weather-canvas');
        // Initialize canvas context with transparency support
        // NOTE: desynchronized:true breaks transparency in OBS Browser Source (CEF v103-107)
        // The desynchronized option improves performance in browsers but causes OBS CEF
        // to render the canvas in a separate GPU thread, breaking alpha channel reading
        const ctx = canvas.getContext('2d', { 
            alpha: true,
            willReadFrequently: false,
            premultipliedAlpha: true  // Ensure proper alpha blending
        });
        const debugInfo = document.getElementById('debug-info');
        const lightningFlash = document.getElementById('lightning-flash');
        const connectionStatus = document.getElementById('connection-status');

        // Verify context initialization for transparency
        if (!ctx) {
            console.error('‚ùå Failed to get 2D context! Canvas rendering will not work.');
            // Show error and stop execution
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,0,0,0.9);color:white;padding:20px;border-radius:10px;font-family:monospace;text-align:center;z-index:99999;';
            errorDiv.textContent = '‚ùå Canvas context initialization failed. Please check your browser settings.';
            document.body.appendChild(errorDiv);
            throw new Error('Canvas context initialization failed');
        }
        
        // Get context attributes once
        const contextAttrs = ctx.getContextAttributes();
        log(`‚úÖ Canvas context initialized with alpha: ${contextAttrs.alpha}`);
        log(`Canvas context attributes: ${JSON.stringify(contextAttrs)}`);

        // Safe GSAP wrapper - fallback to setTimeout if GSAP not available
        const safeGsap = (() => {
            // Helper function to apply properties to target
            // GSAP-specific properties to exclude from direct assignment (GSAP 3.x)
            const gsapProps = ['duration', 'delay', 'ease', 'onComplete', 'repeat', 'yoyo', 'stagger', 'yoyoEase', 'onStart', 'onUpdate', 'onRepeat', 'repeatDelay'];
            
            function applyProperties(target, vars) {
                Object.keys(vars).forEach(key => {
                    if (!gsapProps.includes(key)) {
                        if (typeof target === 'object' && target !== null) {
                            try {
                                // Check if target is a DOM element with a style property
                                if (target.style && typeof target.style === 'object') {
                                    // Apply CSS properties via style
                                    target.style[key] = vars[key];
                                } else {
                                    // Apply directly to object (for plain objects)
                                    target[key] = vars[key];
                                }
                            } catch (error) {
                                // Silently ignore invalid property assignments
                                console.debug(`Could not apply property ${key} to target:`, error);
                            }
                        }
                    }
                });
            }
            
            return {
                to: (target, vars) => {
                    if (typeof gsap !== 'undefined') {
                        return gsap.to(target, vars);
                    } else {
                        // Fallback: apply properties directly without animation
                        // In the fallback, we skip the "animation" so we apply immediately
                        // The delay represents when the animation would start, so we delay the property application
                        const applyDelay = (vars.delay || 0) * 1000;
                        
                        setTimeout(() => {
                            applyProperties(target, vars);
                            
                            // Call onComplete after duration (since animation is instant in fallback)
                            if (vars.onComplete) {
                                const completionDelay = (vars.duration || 0) * 1000;
                                setTimeout(vars.onComplete, completionDelay);
                            }
                        }, applyDelay);
                        
                        return { kill: () => {} };
                    }
                },
                set: (target, vars) => {
                    if (typeof gsap !== 'undefined') {
                        return gsap.set(target, vars);
                    } else {
                        // Fallback: apply properties directly
                        applyProperties(target, vars);
                        return { kill: () => {} };
                    }
                }
            };
        })();

        // Responsive canvas sizing with device pixel ratio support
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            ctx.scale(dpr, dpr);
            
            // Ensure canvas starts with transparent background
            ctx.clearRect(0, 0, displayWidth, displayHeight);
            
            log(`Canvas resized: ${displayWidth}x${displayHeight} (DPR: ${dpr})`);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Visual effect constants
        const FOG_MAX_ALPHA = 0.25;
        const SNOWFLAKE_SPARKLE_CHANCE = 0.04;
        const GLITCH_LINE_FREQUENCY = 0.2;
        const DIGITAL_NOISE_FREQUENCY = 0.25;
        const FIXED_TIMESTEP = 1000 / 60;
        const MAX_ACCUMULATED = 200;
        
        // Lightning effect constants
        const LIGHTNING_MAX_SEGMENTS_PER_BOLT = 200; // Hard limit per bolt
        const LIGHTNING_BRANCH_THRESHOLD = 180; // Stop branching when approaching limit
        const LIGHTNING_DEBUG_THRESHOLD = 150; // Log when segment count is high
        const LIGHTNING_MAX_TOTAL_SEGMENTS = 1000; // Overflow protection
        const LIGHTNING_MAX_CONCURRENT = 3; // Maximum simultaneous lightning bolts

        /**
         * SimplexNoise - Lightweight Simplex noise implementation for fog effects
         */
        class SimplexNoise {
            constructor(random = Math.random) {
                this.grad3 = [
                    [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                    [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                    [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
                ];
                this.p = [];
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(random() * 256);
                }
                this.perm = [];
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                }
            }

            dot(g, x, y) {
                return g[0] * x + g[1] * y;
            }

            noise2D(xin, yin) {
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                
                let n0, n1, n2;
                const s = (xin + yin) * F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                
                let i1, j1;
                if (x0 > y0) {
                    i1 = 1; j1 = 0;
                } else {
                    i1 = 0; j1 = 1;
                }
                
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii + this.perm[jj]] % 12;
                const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
                const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
                
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                
                return 70.0 * (n0 + n1 + n2);
            }
        }

        /**
         * Koch Snowflake Generator
         */
        function generateKochSnowflake(iterations = 2) {
            let points = [
                { x: 0, y: -1 },
                { x: Math.cos(-Math.PI / 6), y: Math.sin(-Math.PI / 6) },
                { x: Math.cos(-5 * Math.PI / 6), y: Math.sin(-5 * Math.PI / 6) }
            ];
            
            for (let iter = 0; iter < iterations; iter++) {
                points = kochIteration(points);
            }
            return points;
        }

        function kochIteration(points) {
            const newPoints = [];
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                
                newPoints.push({ x: p1.x, y: p1.y });
                newPoints.push({ x: p1.x + dx / 3, y: p1.y + dy / 3 });
                
                const midX = p1.x + dx / 2;
                const midY = p1.y + dy / 2;
                const px = p1.x + dx / 3;
                const py = p1.y + dy / 3;
                const angle = Math.PI / 3;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                newPoints.push({
                    x: px + (midX - px) * cos - (midY - py) * sin,
                    y: py + (midX - px) * sin + (midY - py) * cos
                });
                
                newPoints.push({ x: p1.x + 2 * dx / 3, y: p1.y + 2 * dy / 3 });
            }
            return newPoints;
        }

        function generateSnowflakeVariants() {
            const variants = [];
            for (let i = 0; i < 5; i++) {
                const iterations = 1 + Math.floor(i / 2);
                variants.push(generateKochSnowflake(iterations));
            }
            return variants;
        }

        /**
         * ParticlePool - Object pooling system
         */
        class ParticlePool {
            constructor(ParticleClass, particleType, initialSize = 500) {
                this.ParticleClass = ParticleClass;
                this.particleType = particleType;
                this.available = [];
                this.active = new Set();
                this.peakUsage = 0;
                this.totalAcquired = 0;
                
                for (let i = 0; i < initialSize; i++) {
                    this.available.push(new ParticleClass(particleType));
                }
            }

            acquire(config) {
                let particle;
                if (this.available.length > 0) {
                    particle = this.available.pop();
                } else {
                    particle = new this.ParticleClass(this.particleType);
                }
                
                particle.reset(config);
                this.active.add(particle);
                this.totalAcquired++;
                this.peakUsage = Math.max(this.peakUsage, this.active.size);
                
                return particle;
            }

            release(particle) {
                if (this.active.has(particle)) {
                    particle.active = false;
                    this.active.delete(particle);
                    this.available.push(particle);
                }
            }

            releaseAll() {
                this.active.forEach(particle => {
                    particle.active = false;
                    this.available.push(particle);
                });
                this.active.clear();
            }

            getStats() {
                return {
                    available: this.available.length,
                    active: this.active.size,
                    total: this.available.length + this.active.size,
                    peakUsage: this.peakUsage,
                    totalAcquired: this.totalAcquired
                };
            }
        }

        // Initialize particle pools and other globals
        const pools = {
            rain: null,
            snow: null,
            storm: null,
            fog: null
        };
        const snowflakeVariants = generateSnowflakeVariants();
        const noise = new SimplexNoise();
        let globalWind = 0;

        // Lightning segments for procedural lightning
        let lightningSegments = [];
        let lightningFadeTime = 0;

        // State management
        const state = {
            activeEffects: [],
            particles: [],
            socket: null,
            connected: false,
            reconnectAttempts: 0,
            animationId: null,
            lastFrameTime: 0,
            accumulator: 0,
            fps: 0,
            fpsHistory: [],
            totalEventsReceived: 0,
            effectQueue: [],
            maxConcurrentEffects: 3,
            maxQueueLength: 66
        };

        // Particle class with optimized rendering
        class Particle {
            constructor(type, config = {}) {
                this.type = type;
                this.active = true;
                this.reset(config);
            }

            reset(config = {}) {
                const w = config.width || window.innerWidth;
                const h = config.height || window.innerHeight;
                
                this.x = config.x !== undefined ? config.x : Math.random() * w;
                this.y = config.startFromTop ? -20 : (config.y !== undefined ? config.y : Math.random() * h);
                this.z = Math.random();
                this.active = true;
                
                this.prevX = this.x;
                this.prevY = this.y;
                
                switch (this.type) {
                    case 'rain':
                        this.speedY = 15 + Math.random() * 15;
                        this.speedX = Math.random() * 3 - 1.5;
                        this.length = 15 + Math.random() * 25;
                        this.width = 1 + Math.random() * 1.5;
                        this.alpha = 0.4 + Math.random() * 0.4;
                        this.color = `rgba(160, 196, 232, ${this.alpha})`;
                        this.wind = 0;
                        this.turbulence = 0;
                        this.splashing = false;
                        this.splashParticles = [];
                        break;
                    
                    case 'snow':
                        this.speedY = 1 + Math.random() * 2.5;
                        this.speedX = Math.random() * 2 - 1;
                        this.size = 2 + Math.random() * 5;
                        this.alpha = 0.5 + Math.random() * 0.5;
                        this.wobble = Math.random() * Math.PI * 2;
                        this.wobbleSpeed = 0.02 + Math.random() * 0.04;
                        this.rotation = Math.random() * Math.PI * 2;
                        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                        this.variant = Math.floor(Math.random() * 5);
                        if (!config.snowflakeVariants) {
                            this.snowflakePoints = null;
                        } else {
                            this.snowflakePoints = config.snowflakeVariants[this.variant];
                        }
                        break;
                    
                    case 'storm':
                        this.speedY = 20 + Math.random() * 20;
                        this.speedX = 8 + Math.random() * 12;
                        this.length = 20 + Math.random() * 35;
                        this.width = 1.5 + Math.random() * 2;
                        this.alpha = 0.5 + Math.random() * 0.4;
                        this.color = `rgba(107, 163, 214, ${this.alpha})`;
                        break;
                    
                    case 'fog':
                        this.speedY = 0.3 + Math.random() * 0.4;
                        this.speedX = 0.5 + Math.random() - 0.5;
                        this.size = 60 + Math.random() * 140; // Optimized: 60-200px (was 80-280px)
                        this.alpha = FOG_MAX_ALPHA; // Start at max alpha for immediate visibility
                        this.life = 0;
                        this.maxLife = 350 + Math.random() * 500; // Extended: 350-850ms (was 250-650ms)
                        this.hue = 200 + Math.random() * 20;
                        break;
                }
            }

            update(deltaTime, intensity = 1.0, dimensions = null, globalWindParam = 0, currentTime = Date.now()) {
                const speed = deltaTime / 16.67;
                const w = dimensions?.width || window.innerWidth;
                const h = dimensions?.height || window.innerHeight;
                
                this.prevX = this.x;
                this.prevY = this.y;
                
                switch (this.type) {
                    case 'rain':
                        this.wind = globalWindParam + (Math.random() - 0.5) * 2;
                        this.turbulence = Math.sin(currentTime * 0.01 + this.x * 0.1) * 0.5;
                        
                        this.x += (this.speedX + this.wind + this.turbulence) * speed;
                        this.y += this.speedY * speed * intensity;
                        
                        if (this.y > h - 10 && !this.splashing) {
                            this.triggerSplash();
                        }
                        
                        if (this.splashParticles.length > 0) {
                            for (let i = 0; i < this.splashParticles.length; i++) {
                                const splash = this.splashParticles[i];
                                splash.x += splash.vx * speed;
                                splash.y += splash.vy * speed;
                                splash.vy += 0.2 * speed;
                                splash.life -= 0.05 * speed;
                            }
                            this.splashParticles = this.splashParticles.filter(s => s.life > 0);
                        }
                        
                        if (this.y > h + 20) {
                            this.reset({ startFromTop: true, width: w, height: h });
                        }
                        if (this.x < -20 || this.x > w + 20) {
                            this.x = Math.random() * w;
                        }
                        break;
                    
                    case 'snow':
                        this.y += this.speedY * speed * intensity;
                        this.wobble += this.wobbleSpeed * speed;
                        this.x += Math.sin(this.wobble) * 0.8 * speed + this.speedX * speed;
                        this.rotation += this.rotationSpeed * speed;
                        if (this.y > h + 20) {
                            this.reset({ startFromTop: true, width: w, height: h });
                        }
                        if (this.x < -20) this.x = w + 20;
                        if (this.x > w + 20) this.x = -20;
                        break;
                    
                    case 'storm':
                        this.y += this.speedY * speed * intensity;
                        this.x += this.speedX * speed * intensity;
                        if (this.y > h + 50) {
                            this.reset({ startFromTop: true, width: w, height: h });
                        }
                        if (this.x > w + 100) {
                            this.x = -100;
                            this.y = Math.random() * h;
                        }
                        break;
                    
                    case 'fog':
                        this.y += this.speedY * speed;
                        this.x += this.speedX * speed;
                        this.life += speed;
                        const lifePercent = this.life / this.maxLife;
                        // Linear fade-in/sustain/fade-out curve for better visibility
                        // 0-20%: Fade in, 20-80%: Sustain, 80-100%: Fade out
                        if (lifePercent < 0.2) {
                            this.alpha = (lifePercent / 0.2) * FOG_MAX_ALPHA;
                        } else if (lifePercent < 0.8) {
                            this.alpha = FOG_MAX_ALPHA;
                        } else {
                            this.alpha = ((1 - lifePercent) / 0.2) * FOG_MAX_ALPHA;
                        }
                        if (this.life > this.maxLife) {
                            this.reset({ width: w, height: h });
                        }
                        if (this.x < -this.size) this.x = w + this.size;
                        if (this.x > w + this.size) this.x = -this.size;
                        break;
                }
            }

            triggerSplash() {
                this.splashing = true;
                const splashCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < splashCount; i++) {
                    this.splashParticles.push({
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -2 - Math.random() * 2,
                        life: 1.0,
                        size: 1 + Math.random()
                    });
                }
            }

            draw() {
                if (!this.active || !ctx) return;
                
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                switch (this.type) {
                    case 'rain':
                    case 'storm':
                    {
                        const gradient = ctx.createLinearGradient(
                            this.x, this.y,
                            this.x - this.speedX * 2, this.y - this.length
                        );
                        const baseColor = this.color || (this.type === 'storm' ? 'rgba(107, 163, 214, ' + this.alpha + ')' : 'rgba(160, 196, 232, ' + this.alpha + ')');
                        const transparentColor = this.type === 'storm' ? 'rgba(107, 163, 214, 0)' : 'rgba(160, 196, 232, 0)';
                        gradient.addColorStop(0, baseColor);
                        gradient.addColorStop(1, transparentColor);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = this.width;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x - this.speedX * 2, this.y - this.length);
                        ctx.stroke();
                        
                        if (this.type === 'rain' && this.splashParticles.length > 0) {
                            this.splashParticles.forEach(splash => {
                                ctx.globalAlpha = splash.life * 0.6;
                                ctx.fillStyle = 'rgba(180, 210, 240, 1)';
                                ctx.beginPath();
                                ctx.arc(splash.x, splash.y, splash.size, 0, Math.PI * 2);
                                ctx.fill();
                            });
                        }
                        break;
                    }
                    
                    case 'snow':
                    {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.rotation);
                        
                        if (this.snowflakePoints && this.snowflakePoints.length > 0) {
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            for (let i = 0; i < this.snowflakePoints.length; i++) {
                                const x = this.snowflakePoints[i].x * this.size;
                                const y = this.snowflakePoints[i].y * this.size;
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                            ctx.closePath();
                            ctx.fill();
                        } else {
                            const points = 6;
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            for (let i = 0; i < points; i++) {
                                const angle = (i * Math.PI * 2) / points;
                                const x = Math.cos(angle) * this.size;
                                const y = Math.sin(angle) * this.size;
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        if (Math.random() < SNOWFLAKE_SPARKLE_CHANCE) {
                            ctx.fillStyle = '#ffffdd';
                            ctx.globalAlpha = 0.9;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.size * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                        break;
                    }
                    
                    case 'fog':
                    {
                        const fogGradient = ctx.createRadialGradient(
                            this.x, this.y, 0,
                            this.x, this.y, this.size
                        );
                        fogGradient.addColorStop(0, `hsla(${this.hue}, 15%, 75%, ${this.alpha})`);
                        fogGradient.addColorStop(0.5, `hsla(${this.hue}, 15%, 70%, ${this.alpha * 0.5})`);
                        fogGradient.addColorStop(1, 'rgba(180, 180, 200, 0)');
                        ctx.fillStyle = fogGradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    }
                }
                
                ctx.restore();
            }

            destroy() {
                this.active = false;
            }
        }

        // Initialize particle pools after Particle class is defined
        pools.rain = new ParticlePool(Particle, 'rain', 500);
        pools.snow = new ParticlePool(Particle, 'snow', 500);
        pools.storm = new ParticlePool(Particle, 'storm', 500);
        pools.fog = new ParticlePool(Particle, 'fog', 100);

        // Effect handlers with GSAP animations
        const effects = {
            rain: {
                start(intensity = 0.5, duration = 10000, options = {}) {
                    const isPermanent = options.permanent === true;
                    const particleCount = Math.floor(250 * intensity);
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = pools.rain.acquire({
                            width: window.innerWidth,
                            height: window.innerHeight
                        });
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'rain',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        permanent: isPermanent,
                        particles: newParticles,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`üåßÔ∏è Rain effect started (${particleCount} particles, ${isPermanent ? 'permanent' : `${duration}ms`})`);
                    
                    if (!isPermanent) {
                        effect.timerId = setTimeout(() => effects.rain.stop(effect), duration);
                    }
                },
                stop(effect) {
                    if (!effect) {
                        state.activeEffects.filter(e => e.type === 'rain').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                            e.particles.forEach(p => pools.rain.release(p));
                        });
                        state.particles = state.particles.filter(p => p.type !== 'rain');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'rain');
                        log('üåßÔ∏è All rain effects stopped');
                        processEffectQueue();
                    } else {
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        effect.particles.forEach(p => pools.rain.release(p));
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('üåßÔ∏è Rain effect stopped');
                        processEffectQueue();
                    }
                }
            },

            snow: {
                start(intensity = 0.5, duration = 10000, options = {}) {
                    const isPermanent = options.permanent === true;
                    const particleCount = Math.floor(180 * intensity);
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = pools.snow.acquire({
                            width: window.innerWidth,
                            height: window.innerHeight,
                            snowflakeVariants: snowflakeVariants
                        });
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'snow',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        permanent: isPermanent,
                        particles: newParticles,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚ùÑÔ∏è Snow effect started (${particleCount} particles, ${isPermanent ? 'permanent' : `${duration}ms`})`);
                    
                    if (!isPermanent) {
                        effect.timerId = setTimeout(() => effects.snow.stop(effect), duration);
                    }
                },
                stop(effect) {
                    if (!effect) {
                        state.activeEffects.filter(e => e.type === 'snow').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                            e.particles.forEach(p => pools.snow.release(p));
                        });
                        state.particles = state.particles.filter(p => p.type !== 'snow');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'snow');
                        log('‚ùÑÔ∏è All snow effects stopped');
                        processEffectQueue();
                    } else {
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        effect.particles.forEach(p => pools.snow.release(p));
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚ùÑÔ∏è Snow effect stopped');
                        processEffectQueue();
                    }
                }
            },

            storm: {
                start(intensity = 0.7, duration = 8000, options = {}) {
                    const isPermanent = options.permanent === true;
                    const particleCount = Math.floor(300 * intensity);
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = pools.storm.acquire({
                            width: window.innerWidth,
                            height: window.innerHeight
                        });
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'storm',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        permanent: isPermanent,
                        particles: newParticles,
                        nextShake: Date.now() + Math.random() * 1500,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚õàÔ∏è Storm effect started (${particleCount} particles, ${isPermanent ? 'permanent' : `${duration}ms`})`);
                    
                    safeGsap.to(canvas.style, {
                        filter: 'brightness(0.85)',
                        duration: 0.5,
                        ease: 'power2.inOut'
                    });
                    
                    if (!isPermanent) {
                        effect.timerId = setTimeout(() => effects.storm.stop(effect), duration);
                    }
                },
                stop(effect) {
                    if (!effect) {
                        state.activeEffects.filter(e => e.type === 'storm').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                            e.particles.forEach(p => pools.storm.release(p));
                        });
                        state.particles = state.particles.filter(p => p.type !== 'storm');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'storm');
                        processEffectQueue();
                    } else {
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        effect.particles.forEach(p => pools.storm.release(p));
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        processEffectQueue();
                    }
                    
                    const hasStorm = state.activeEffects.some(e => e.type === 'storm');
                    if (!hasStorm) {
                        safeGsap.to(canvas.style, {
                            filter: 'brightness(1)',
                            duration: 0.8,
                            ease: 'power2.inOut'
                        });
                    }
                    
                    log('‚õàÔ∏è Storm effect stopped');
                }
            },

            fog: {
                start(intensity = 0.4, duration = 15000, options = {}) {
                    const isPermanent = options.permanent === true;
                    const particleCount = Math.floor(80 * intensity); // Increased from 30 to 80 particles
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = pools.fog.acquire({
                            width: window.innerWidth,
                            height: window.innerHeight
                        });
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'fog',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        permanent: isPermanent,
                        particles: newParticles,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`üå´Ô∏è Fog effect started (${particleCount} particles, ${isPermanent ? 'permanent' : `${duration}ms`})`);
                    
                    if (!isPermanent) {
                        effect.timerId = setTimeout(() => effects.fog.stop(effect), duration);
                    }
                },
                stop(effect) {
                    if (!effect) {
                        state.activeEffects.filter(e => e.type === 'fog').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                            e.particles.forEach(p => pools.fog.release(p));
                        });
                        state.particles = state.particles.filter(p => p.type !== 'fog');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'fog');
                        log('üå´Ô∏è All fog effects stopped');
                        processEffectQueue();
                    } else {
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        effect.particles.forEach(p => pools.fog.release(p));
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('üå´Ô∏è Fog effect stopped');
                        processEffectQueue();
                    }
                }
            },

            thunder: {
                start(intensity = 0.8, duration = 5000, options = {}) {
                    const isPermanent = options.permanent === true;
                    const effect = {
                        type: 'thunder',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        permanent: isPermanent,
                        nextFlash: Date.now() + Math.random() * 800,
                        flashCount: 0,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚ö° Thunder effect started (${isPermanent ? 'permanent' : `${duration}ms`})`);
                    
                    // Schedule auto-stop and store timer ID
                    if (!isPermanent) {
                        effect.timerId = setTimeout(() => effects.thunder.stop(effect), duration);
                    }
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all thunder effects
                        state.activeEffects.filter(e => e.type === 'thunder').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'thunder');
                        log('‚ö° All thunder effects stopped');
                        processEffectQueue(); // Process queue when effects stop
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚ö° Thunder effect stopped');
                        processEffectQueue(); // Process queue when an effect stops
                    }
                }
            },

            sunbeam: {
                start(intensity = 0.6, duration = 12000, options = {}) {
                    const isPermanent = options.permanent === true;
                    const beamCount = 6;
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    
                    const effect = {
                        type: 'sunbeam',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        permanent: isPermanent,
                        beams: Array.from({ length: beamCount }, (_, i) => ({
                            x: (w / beamCount) * i + Math.random() * (w / beamCount),
                            angle: Math.random() * Math.PI / 6 - Math.PI / 12,
                            width: 60 + Math.random() * 120,
                            speed: 0.3 + Math.random() * 0.5,
                            opacity: 0
                        })),
                        timerId: null,
                        fadeTimerId: null
                    };
                    
                    // Fade in beams
                    effect.beams.forEach((beam, i) => {
                        safeGsap.to(beam, {
                            opacity: 1,
                            duration: 1,
                            delay: i * 0.1,
                            ease: 'power2.inOut'
                        });
                    });
                    
                    state.activeEffects.push(effect);
                    log(`‚òÄÔ∏è Sunbeam effect started (${beamCount} beams, ${isPermanent ? 'permanent' : `${duration}ms`})`);
                    
                    if (!isPermanent) {
                        // Fade out before stopping
                        effect.fadeTimerId = setTimeout(() => {
                            effect.beams.forEach((beam, i) => {
                                safeGsap.to(beam, {
                                    opacity: 0,
                                    duration: 1,
                                    delay: i * 0.05,
                                    ease: 'power2.inOut'
                                });
                            });
                        }, Math.max(0, duration - 1200));
                        
                        // Schedule auto-stop and store timer ID
                        effect.timerId = setTimeout(() => effects.sunbeam.stop(effect), duration);
                    }
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all sunbeam effects
                        state.activeEffects.filter(e => e.type === 'sunbeam').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                            if (e.fadeTimerId) clearTimeout(e.fadeTimerId);
                        });
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'sunbeam');
                        log('‚òÄÔ∏è All sunbeam effects stopped');
                        processEffectQueue(); // Process queue when effects stop
                    } else {
                        // Cancel timers to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        if (effect.fadeTimerId) {
                            clearTimeout(effect.fadeTimerId);
                            effect.fadeTimerId = null;
                        }
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚òÄÔ∏è Sunbeam effect stopped');
                        processEffectQueue(); // Process queue when an effect stops
                    }
                }
            },

            glitchclouds: {
                start(intensity = 0.7, duration = 8000, options = {}) {
                    const isPermanent = options.permanent === true;
                    const effect = {
                        type: 'glitchclouds',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        permanent: isPermanent,
                        glitchLines: [],
                        glitchInterval: null,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚òÅÔ∏è Glitch Clouds effect started (${isPermanent ? 'permanent' : `${duration}ms`})`);
                    
                    // Schedule auto-stop and store timer ID
                    if (!isPermanent) {
                        effect.timerId = setTimeout(() => effects.glitchclouds.stop(effect), duration);
                    }
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all glitch clouds effects
                        state.activeEffects.filter(e => e.type === 'glitchclouds').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'glitchclouds');
                        log('‚òÅÔ∏è All glitch clouds effects stopped');
                        processEffectQueue(); // Process queue when effects stop
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚òÅÔ∏è Glitch clouds effect stopped');
                        processEffectQueue(); // Process queue when an effect stops
                    }
                }
            }
        };

        // Update physics with fixed timestep
        function updatePhysics(deltaTime, currentTime) {
            globalWind = Math.sin(currentTime * 0.0005) * 3;
            
            for (const particle of state.particles) {
                if (!particle.active) continue;
                
                const effect = state.activeEffects.find(e =>
                    e.particles && e.particles.includes(particle)
                );
                const intensity = effect ? effect.intensity : 1.0;
                const dimensions = { width: window.innerWidth, height: window.innerHeight };
                
                particle.update(deltaTime, intensity, dimensions, globalWind, currentTime);
            }
            
            state.particles = state.particles.filter(p => p.active);
        }

        // Render with interpolation
        function renderInterpolated(alpha) {
            for (const particle of state.particles) {
                if (!particle.active) continue;
                
                const renderX = particle.prevX + (particle.x - particle.prevX) * alpha;
                const renderY = particle.prevY + (particle.y - particle.prevY) * alpha;
                
                const origX = particle.x;
                const origY = particle.y;
                particle.x = renderX;
                particle.y = renderY;
                
                particle.draw();
                
                particle.x = origX;
                particle.y = origY;
            }
        }

        // Render loop with fixed timestep
        function render(timestamp) {
            const deltaTime = Math.min(timestamp - state.lastFrameTime, 100);
            state.lastFrameTime = timestamp;

            const w = window.innerWidth;
            const h = window.innerHeight;
            
            ctx.clearRect(0, 0, w, h);

            if (deltaTime > 0) {
                state.fps = Math.round(1000 / deltaTime);
                state.fpsHistory.push(state.fps);
                if (state.fpsHistory.length > 60) state.fpsHistory.shift();
            }

            state.accumulator += deltaTime;
            state.accumulator = Math.min(state.accumulator, MAX_ACCUMULATED);
            
            const currentTime = Date.now();
            while (state.accumulator >= FIXED_TIMESTEP) {
                updatePhysics(FIXED_TIMESTEP, currentTime);
                state.accumulator -= FIXED_TIMESTEP;
            }
            
            const alpha = state.accumulator / FIXED_TIMESTEP;
            renderInterpolated(alpha);

            for (let i = state.activeEffects.length - 1; i >= 0; i--) {
                const effect = state.activeEffects[i];
                const elapsed = currentTime - effect.startTime;
                const isPermanent = effect.permanent === true;
                
                if (!isPermanent && elapsed > effect.duration + 1000) {
                    state.activeEffects.splice(i, 1);
                    continue;
                }

                if (effect.type === 'thunder') {
                    handleThunder(effect);
                }

                if (effect.type === 'sunbeam' && effect.beams) {
                    drawSunbeams(effect);
                }

                if (effect.type === 'fog') {
                    drawVolumetricFog(effect);
                }

                if (effect.type === 'glitchclouds') {
                    drawGlitchClouds(effect);
                }

                if (effect.type === 'storm' && Date.now() >= effect.nextShake) {
                    shakeCamera(effect.intensity);
                    effect.nextShake = Date.now() + 800 + Math.random() * 2500;
                }
            }

            if (config.debug) {
                updateDebugInfo();
            }

            state.animationId = requestAnimationFrame(render);
        }

        // Handle thunder effect with procedural lightning
        function handleThunder(effect) {
            const now = Date.now();
            
            // Count active lightning bolts
            const activeLightningCount = state.activeEffects.filter(e => 
                e.type === 'thunder' && e.lightningActive
            ).length;
            
            if (now >= effect.nextFlash) {
                // Limit concurrent lightning bolts to prevent performance degradation
                if (activeLightningCount < LIGHTNING_MAX_CONCURRENT) {
                    // Check for segment overflow before generating new bolt
                    if (lightningSegments.length > LIGHTNING_MAX_TOTAL_SEGMENTS) {
                        log(`‚ö†Ô∏è Lightning segment overflow detected (${lightningSegments.length} segments), clearing`, 'warn');
                        lightningSegments = [];
                    }
                    
                    generateLightningBolt();
                    effect.flashCount = (effect.flashCount || 0) + 1;
                    effect.lightningActive = true; // Mark as active
                    effect.nextFlash = now + 400 + Math.random() * 2500;
                    triggerLightning(effect.intensity);
                }
            }
            
            if (lightningSegments.length > 0 && now < lightningFadeTime) {
                const fadeProgress = 1 - (lightningFadeTime - now) / 150;
                drawLightning(fadeProgress);
            } else if (now >= lightningFadeTime && lightningSegments.length > 0) {
                // Clear segments after fade completes (memory leak fix)
                lightningSegments = [];
                effect.lightningActive = false; // Mark as inactive
            }
        }

        // Generate procedural lightning bolt
        function generateLightningBolt() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            const startX = Math.random() * w;
            const startY = 0;
            const endX = startX + (Math.random() - 0.5) * w * 0.3;
            const endY = h;
            
            // Clear old segments before generating new bolt
            const segmentCount = { count: 0 };
            lightningSegments = subdivideLightning(startX, startY, endX, endY, 6, 1.0, segmentCount);
            lightningFadeTime = Date.now() + 150;
            
            // Debug logging for high segment count monitoring
            if (segmentCount.count > LIGHTNING_DEBUG_THRESHOLD) {
                log(`‚ö° Lightning generated with ${segmentCount.count} segments (threshold: ${LIGHTNING_DEBUG_THRESHOLD})`, 'debug');
            }
        }

        // Recursive lightning subdivision with segment limits
        function subdivideLightning(x1, y1, x2, y2, generations, brightness, segmentCount = { count: 0 }) {
            const segments = [];
            
            // Hard limit: prevent unbounded segment growth
            if (segmentCount.count >= LIGHTNING_MAX_SEGMENTS_PER_BOLT) {
                return segments;
            }
            
            if (generations === 0) {
                segments.push({ x1, y1, x2, y2, brightness });
                segmentCount.count++;
                return segments;
            }
            
            const midX = (x1 + x2) / 2 + (Math.random() - 0.5) * (x2 - x1) * 0.4;
            const midY = (y1 + y2) / 2 + (Math.random() - 0.5) * 50;
            
            segments.push(...subdivideLightning(x1, y1, midX, midY, generations - 1, brightness, segmentCount));
            segments.push(...subdivideLightning(midX, midY, x2, y2, generations - 1, brightness * 0.9, segmentCount));
            
            // Reduced branching probability: decreases at higher recursion depths
            const branchProbability = 0.3 * Math.pow(0.7, 6 - generations);
            // Secondary limit: stop branching when approaching hard limit
            if (Math.random() < branchProbability && generations > 2 && segmentCount.count < LIGHTNING_BRANCH_THRESHOLD) {
                const branchAngle = (Math.random() - 0.5) * Math.PI / 3;
                const branchLength = Math.hypot(x2 - midX, y2 - midY) * 0.6;
                const branchEndX = midX + Math.cos(branchAngle) * branchLength;
                const branchEndY = midY + Math.sin(branchAngle) * branchLength + branchLength * 0.5;
                segments.push(...subdivideLightning(midX, midY, branchEndX, branchEndY, generations - 2, brightness * 0.5, segmentCount));
            }
            
            return segments;
        }

        // Draw lightning with glow effect
        function drawLightning(fadeProgress) {
            ctx.save();
            
            const alpha = 1 - fadeProgress;
            
            ctx.shadowColor = `rgba(180, 200, 255, ${0.8 * alpha})`;
            ctx.shadowBlur = 30;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const widths = [15, 8, 3, 1];
            widths.forEach((width, i) => {
                ctx.lineWidth = width;
                const baseAlpha = alpha * (i === 3 ? 1 : (0.3 - i * 0.05));
                ctx.strokeStyle = i === 3 
                    ? `rgba(255, 255, 255, ${baseAlpha})` 
                    : `rgba(200, 220, 255, ${baseAlpha})`;
                
                ctx.beginPath();
                lightningSegments.forEach(seg => {
                    ctx.moveTo(seg.x1, seg.y1);
                    ctx.lineTo(seg.x2, seg.y2);
                });
                ctx.stroke();
            });
            
            ctx.restore();
        }

        // Lightning flash effect with GSAP
        function triggerLightning(intensity) {
            const maxOpacity = 0.3 + intensity * 0.6;
            
            safeGsap.to(lightningFlash, {
                opacity: maxOpacity,
                duration: 0.05,
                ease: 'power4.in',
                onComplete: () => {
                    safeGsap.to(lightningFlash, {
                        opacity: 0,
                        duration: 0.1,
                        ease: 'power2.out'
                    });
                }
            });

            // Sometimes double flash for realism
            if (Math.random() > 0.5) {
                safeGsap.to(lightningFlash, {
                    opacity: maxOpacity * 0.6,
                    duration: 0.04,
                    delay: 0.12,
                    ease: 'power4.in',
                    onComplete: () => {
                        safeGsap.to(lightningFlash, {
                            opacity: 0,
                            duration: 0.08,
                            ease: 'power2.out'
                        });
                    }
                });
            }
        }

        // Camera shake effect with GSAP
        function shakeCamera(intensity) {
            const shakeAmount = 6 * intensity;
            const shakeDuration = 0.5;
            
            safeGsap.to(canvas, {
                x: `+=${(Math.random() - 0.5) * shakeAmount}`,
                y: `+=${(Math.random() - 0.5) * shakeAmount}`,
                duration: 0.05,
                repeat: 8,
                yoyo: true,
                ease: 'power1.inOut',
                onComplete: () => {
                    safeGsap.set(canvas, { x: 0, y: 0 });
                }
            });
        }

        // Draw sunbeams with HDR bloom effect
        function drawSunbeams(effect) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            const w = window.innerWidth;
            
            effect.beams.forEach(beam => {
                beam.x += beam.speed;
                if (beam.x > w + 150) {
                    beam.x = -150;
                }
                
                const bloomPasses = 3;
                for (let pass = 0; pass < bloomPasses; pass++) {
                    const bloomScale = 1 + pass * 0.3;
                    const bloomAlpha = beam.opacity * (1 - pass * 0.3) * effect.intensity;
                    
                    ctx.save();
                    ctx.translate(beam.x, beam.y);
                    ctx.rotate((beam.angle * Math.PI) / 180);
                    ctx.scale(bloomScale, 1);
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, beam.height);
                    gradient.addColorStop(0, `rgba(255, 250, 220, ${bloomAlpha})`);
                    gradient.addColorStop(0.3, `rgba(255, 245, 200, ${bloomAlpha * 0.6})`);
                    gradient.addColorStop(0.6, `rgba(255, 240, 180, ${bloomAlpha * 0.2})`);
                    gradient.addColorStop(1, 'rgba(255, 235, 160, 0)');
                    
                    ctx.beginPath();
                    ctx.moveTo(-beam.width / 2, 0);
                    ctx.lineTo(beam.width / 2, 0);
                    ctx.lineTo(beam.width * 0.1, beam.height);
                    ctx.lineTo(-beam.width * 0.1, beam.height);
                    ctx.closePath();
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                drawDustMotes(beam, effect);
            });
            
            ctx.restore();
        }

        // Draw floating dust particles in sunbeam
        function drawDustMotes(beam, effect) {
            const moteCount = Math.floor(15 * effect.intensity);
            const time = Date.now() * 0.001;
            
            ctx.save();
            for (let i = 0; i < moteCount; i++) {
                const seed = beam.x + beam.y + i;
                const moteY = ((seed * 13 + time * 20) % beam.height);
                const moteX = beam.x + Math.sin(seed + time * 2) * beam.width * 0.4;
                
                ctx.globalAlpha = 0.3 + Math.sin(seed + time * 3) * 0.2;
                ctx.fillStyle = '#ffffdd';
                ctx.beginPath();
                ctx.arc(moteX, beam.y + moteY, 1 + Math.random() * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // Draw volumetric fog with Perlin noise
        function drawVolumetricFog(effect) {
            const time = Date.now() * 0.0005;
            
            for (const particle of effect.particles) {
                if (!particle.active) continue;
                
                ctx.save();
                
                const noiseValue = noise.noise2D(particle.x * 0.005, time);
                const alphaModulation = 0.7 + noiseValue * 0.3;
                
                const layers = 3;
                for (let i = 0; i < layers; i++) {
                    const layerSize = particle.size * (1 - i * 0.2);
                    const layerAlpha = particle.alpha * alphaModulation * (1 - i * 0.3);
                    
                    const offsetX = noise.noise2D(particle.x * 0.003, time + i) * 20;
                    const offsetY = noise.noise2D(particle.y * 0.003, time + i + 10) * 20;
                    
                    const gradient = ctx.createRadialGradient(
                        particle.x + offsetX, particle.y + offsetY, 0,
                        particle.x + offsetX, particle.y + offsetY, layerSize
                    );
                    
                    const hue = particle.hue + i * 5;
                    gradient.addColorStop(0, `hsla(${hue}, 15%, 75%, ${layerAlpha})`);
                    gradient.addColorStop(0.5, `hsla(${hue}, 15%, 70%, ${layerAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(180, 180, 200, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(particle.x + offsetX, particle.y + offsetY, layerSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Draw glitch clouds with improved effects
        function drawGlitchClouds(effect) {
            ctx.save();
            
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            if (Math.random() < GLITCH_LINE_FREQUENCY) {
                const lineCount = Math.floor(5 + Math.random() * 10);
                for (let i = 0; i < lineCount; i++) {
                    const y = Math.random() * h;
                    const height = 1 + Math.random() * 5;
                    const offset = (Math.random() - 0.5) * 20 * effect.intensity;
                    
                    ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff00ff' : '#00ffff';
                    ctx.fillRect(0, y, w, height);
                }
            }
            
            if (Math.random() < DIGITAL_NOISE_FREQUENCY) {
                const noiseIntensity = effect.intensity * 0.05;
                ctx.globalAlpha = noiseIntensity;
                
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const size = 1 + Math.random() * 3;
                    const brightness = Math.random() * 255;
                    
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                    ctx.fillRect(x, y, size, size);
                }
            }
            
            ctx.restore();
        }


        // Debug info display with enhanced metrics
        function updateDebugInfo() {
            debugInfo.classList.add('active');
            const avgFps = state.fpsHistory.length > 0 
                ? Math.round(state.fpsHistory.reduce((a, b) => a + b, 0) / state.fpsHistory.length)
                : 0;
            
            const connectionStatusText = state.connected ? 'Connected' : 'Disconnected';
            const connectionClass = state.connected ? 'connected' : 'disconnected';
            
            // Use cached context attributes
            const alphaStatus = contextAttrs.alpha ? '‚úÖ Enabled' : '‚ùå Disabled';
            const premultipliedStatus = contextAttrs.premultipliedAlpha ? '‚úÖ Yes' : '‚ùå No';
            
            debugInfo.innerHTML = `
                <div class="status">
                    <div class="status-dot ${connectionClass}"></div>
                    <strong>Weather Control Debug</strong>
                </div>
                <div style="margin-top: 8px;">
                    <strong>Connection:</strong> ${connectionStatusText}<br>
                    <strong>FPS:</strong> ${state.fps} (avg: ${avgFps})<br>
                    <strong>Particles:</strong> ${state.particles.length} / ${config.maxParticles}<br>
                    <strong>Active Effects:</strong> ${state.activeEffects.length}<br>
                    ${state.activeEffects.map(e => 
                        `  ‚Üí ${e.type} (${Math.round(e.intensity * 100)}%)`
                    ).join('<br>')}
                    <br><strong>Events Received:</strong> ${state.totalEventsReceived}
                    <br><strong>Canvas Alpha:</strong> ${alphaStatus}
                    <br><strong>Premultiplied Alpha:</strong> ${premultipliedStatus}
                    <br><strong>Canvas Size:</strong> ${canvas.width}x${canvas.height}
                    <br><strong>DPR:</strong> ${window.devicePixelRatio || 1}
                </div>
            `;
        }

        // Logging with timestamp
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] [Weather] ${message}`);
        }

        // Connection status display
        function updateConnectionStatus(status, message) {
            if (!config.showConnectionStatus && !config.debug) return;
            
            connectionStatus.className = `show ${status}`;
            connectionStatus.textContent = message;
            
            // Auto-hide success messages after 3 seconds
            if (status === 'connected') {
                setTimeout(() => {
                    connectionStatus.classList.remove('show');
                }, 3000);
            }
        }

        // WebSocket connection with robust error handling and reconnection
        function initSocket() {
            try {
                log('Initializing WebSocket connection...');
                
                state.socket = io({
                    transports: ['websocket', 'polling'],
                    reconnection: true,
                    reconnectionDelay: config.reconnectDelay,
                    reconnectionDelayMax: config.reconnectMaxDelay,
                    reconnectionAttempts: Infinity,
                    timeout: 20000,
                    forceNew: false
                });

                state.socket.on('connect', () => {
                    state.connected = true;
                    state.reconnectAttempts = 0;
                    log('‚úÖ Connected to server');
                    updateConnectionStatus('connected', '‚úì Connected');
                });

                state.socket.on('disconnect', (reason) => {
                    state.connected = false;
                    log(`‚ùå Disconnected from server: ${reason}`);
                    updateConnectionStatus('disconnected', '‚úó Disconnected');
                });

                state.socket.on('reconnect_attempt', (attemptNumber) => {
                    state.reconnectAttempts = attemptNumber;
                    log(`üîÑ Reconnection attempt ${attemptNumber}...`);
                    updateConnectionStatus('reconnecting', `‚ü≥ Reconnecting... (${attemptNumber})`);
                });

                state.socket.on('reconnect', (attemptNumber) => {
                    state.connected = true;
                    state.reconnectAttempts = 0;
                    log(`‚úÖ Reconnected after ${attemptNumber} attempts`);
                    updateConnectionStatus('connected', '‚úì Reconnected');
                });

                state.socket.on('reconnect_error', (error) => {
                    log(`‚ùå Reconnection error: ${error.message}`);
                });

                state.socket.on('reconnect_failed', () => {
                    log('‚ùå Reconnection failed - all attempts exhausted');
                    updateConnectionStatus('disconnected', '‚úó Connection failed');
                });

                state.socket.on('weather:trigger', (data) => {
                    state.totalEventsReceived++;
                    log(`üå¶Ô∏è Received weather event #${state.totalEventsReceived}: ${data.action}`);
                    handleWeatherEvent(data);
                });

                state.socket.on('weather:stop', (data) => {
                    log(`üõë Received weather stop event from ${data.username}`);
                    stopAllEffects();
                });

                state.socket.on('weather:stop-effect', (data) => {
                    if (data?.action && effects[data.action]) {
                        log(`üõë Received stop event for effect: ${data.action}`);
                        stopEffect(data.action);
                    }
                });

                state.socket.on('connect_error', (error) => {
                    log(`‚ùå Connection error: ${error.message}`);
                    updateConnectionStatus('disconnected', `‚úó Error: ${error.message}`);
                });

                state.socket.on('error', (error) => {
                    log(`‚ùå Socket error: ${error.message || error}`);
                });

            } catch (error) {
                log(`‚ùå Failed to initialize socket: ${error.message}`);
                updateConnectionStatus('disconnected', `‚úó Init failed: ${error.message}`);
            }
        }

        // Process queued weather effects
        function processEffectQueue() {
            // Check if we can process more effects
            while (state.activeEffects.length < state.maxConcurrentEffects && state.effectQueue.length > 0) {
                const queuedEvent = state.effectQueue.shift();
                triggerEffectImmediately(queuedEvent);
            }
        }

        // Trigger an effect immediately
        function triggerEffectImmediately(data) {
            try {
                const { action, intensity, duration, username, permanent } = data;
                const validIntensity = Math.max(0, Math.min(1, parseFloat(intensity) || 0.5));
                const isPermanent = permanent === true || duration === 0 || duration === '0';
                const validDuration = isPermanent
                    ? 0
                    : Math.max(1000, Math.min(60000, parseInt(duration) || 10000));
                
                if (isPermanent) {
                    // Ensure only one permanent instance per effect
                    effects[action].stop();
                }

                log(`üé¨ Triggering ${action} (intensity: ${validIntensity}, duration: ${isPermanent ? 'permanent' : `${validDuration}ms`}, user: ${username || 'unknown'})`);
                effects[action].start(validIntensity, validDuration, { permanent: isPermanent });
                
            } catch (error) {
                log(`‚ùå Error triggering weather effect: ${error.message}`);
            }
        }

        // Handle weather events from WebSocket
        function handleWeatherEvent(data) {
            try {
                const { action, intensity, duration, username, permanent } = data;
                
                // Validate event data
                if (!action) {
                    log('‚ö†Ô∏è Invalid event: missing action');
                    return;
                }
                
                if (!effects[action]) {
                    log(`‚ö†Ô∏è Unknown weather effect: ${action}`);
                    return;
                }
                
                const isPermanent = permanent === true || duration === 0 || duration === '0';
                
                // Permanent effects bypass the queue
                if (isPermanent) {
                    triggerEffectImmediately(data);
                    return;
                }
                
                // Check if we can trigger immediately or need to queue
                if (state.activeEffects.length < state.maxConcurrentEffects) {
                    triggerEffectImmediately(data);
                } else {
                    // Add to queue if not full
                    if (state.effectQueue.length < state.maxQueueLength) {
                        state.effectQueue.push(data);
                        log(`üìã Effect queued: ${action} (Queue: ${state.effectQueue.length}/${state.maxQueueLength})`);
                    } else {
                        log(`‚ö†Ô∏è Effect queue full, dropping: ${action}`);
                    }
                }
                
            } catch (error) {
                log(`‚ùå Error handling weather event: ${error.message}`);
            }
        }

        // Stop all active weather effects
        function stopAllEffects() {
            try {
                log('üõë Stopping all weather effects...');
                let stoppedCount = 0;
                
                // Stop all active effects
                for (const effectName in effects) {
                    if (effects[effectName].active) {
                        effects[effectName].stop();
                        stoppedCount++;
                    }
                }
                
                // Clear all particles
                state.particles.length = 0;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                log(`‚úÖ Stopped ${stoppedCount} active effect(s)`);
                
            } catch (error) {
                log(`‚ùå Error stopping effects: ${error.message}`);
            }
        }

        function stopEffect(effectName) {
            if (!effects[effectName]) return;
            effects[effectName].stop();
        }

        // Initialize overlay
        function init() {
            log('üå¶Ô∏è Weather Control Overlay initializing...');
            log(`Version: Modernized v2.0`);
            log(`Debug mode: ${config.debug ? 'ENABLED' : 'disabled'}`);
            log(`Device Pixel Ratio: ${window.devicePixelRatio || 1}`);
            log(`Canvas size: ${canvas.width}x${canvas.height}`);
            log(`Canvas alpha channel: ${contextAttrs.alpha ? 'ENABLED ‚úÖ' : 'DISABLED ‚ùå'}`);
            log(`Premultiplied alpha: ${contextAttrs.premultipliedAlpha ? 'YES ‚úÖ' : 'NO ‚ùå'}`);
            
            // Test transparency by verifying background
            if (config.debug) {
                log('üé® Testing canvas transparency...');
                const testData = ctx.getImageData(0, 0, 1, 1).data;
                log(`Initial canvas pixel RGBA: [${testData[0]}, ${testData[1]}, ${testData[2]}, ${testData[3]}]`);
                if (testData[3] === 0) {
                    log('‚úÖ Canvas background is transparent');
                } else {
                    log(`‚ö†Ô∏è Canvas background may not be fully transparent (alpha: ${testData[3]})`);
                }
            }
            
            // Start render loop
            state.lastFrameTime = performance.now();
            state.animationId = requestAnimationFrame(render);
            
            // Connect to WebSocket
            initSocket();
            
            // Show initial connection status
            if (config.debug || config.showConnectionStatus) {
                updateConnectionStatus('reconnecting', '‚ü≥ Connecting...');
            }
            
            log('‚úÖ Weather Control Overlay initialized successfully');
            log('Waiting for weather events via WebSocket...');
        }

        // Cleanup on unload
        function cleanup() {
            log('üßπ Cleaning up...');
            
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            
            if (state.socket) {
                state.socket.disconnect();
                state.socket = null;
            }
            
            // Clear all effect timers to prevent memory leaks
            state.activeEffects.forEach(effect => {
                if (effect.timerId) {
                    clearTimeout(effect.timerId);
                    effect.timerId = null;
                }
                if (effect.fadeTimerId) {
                    clearTimeout(effect.fadeTimerId);
                    effect.fadeTimerId = null;
                }
            });
            
            // Clear all effects
            state.activeEffects = [];
            state.particles = [];
            
            log('‚úÖ Cleanup complete');
        }

        // Event listeners
        window.addEventListener('load', init);
        window.addEventListener('beforeunload', cleanup);
        
        // Handle visibility changes (for OBS optimization)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('üëÅÔ∏è Page hidden - pausing render loop');
                if (state.animationId) {
                    cancelAnimationFrame(state.animationId);
                    state.animationId = null;
                }
            } else {
                log('üëÅÔ∏è Page visible - resuming render loop');
                if (!state.animationId) {
                    state.lastFrameTime = performance.now();
                    state.animationId = requestAnimationFrame(render);
                }
            }
        });

        // Expose global API for testing (only in debug mode)
        if (config.debug) {
            window.weatherControl = {
                state,
                effects,
                triggerEffect: (action, intensity, duration) => {
                    handleWeatherEvent({ action, intensity, duration });
                },
                clearAll: () => {
                    state.activeEffects.forEach(e => {
                        if (effects[e.type]) {
                            effects[e.type].stop(e);
                        }
                    });
                },
                getStats: () => ({
                    fps: state.fps,
                    particles: state.particles.length,
                    effects: state.activeEffects.length,
                    connected: state.connected,
                    eventsReceived: state.totalEventsReceived
                })
            };
            log('üîß Debug API exposed: window.weatherControl');
        }
    </script>
</body>
</html>
