<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Story - OBS Overlay</title>
  <style id="dynamicStyles">
    /* Styles will be injected based on configuration */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: transparent;
      font-family: var(--font-family, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif);
      overflow: hidden;
      width: var(--overlay-width, 1920px);
      height: var(--overlay-height, 1080px);
    }

    /*
     * Z-index layering (from bottom to top):
     * 1. Image Container (z-index: 1) - Background image
     * 2. Title Overlay (z-index: 2) - Title shown over image initially
     * 3. Text Overlay (z-index: 3) - Star Wars scrolling text over darkened image
     * 4. Voting Overlay (z-index: 4) - Voting choices and timer
     * 5. Results/Generating Overlays (z-index: 5) - Top-most UI elements
     */

    #storyOverlay {
      width: 100%;
      height: 100%;
      position: relative;
      display: none;
    }

    #storyOverlay.active {
      display: block;
    }

    /* Image Container */
    #imageContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 1s ease-in-out, filter 0.8s ease-in-out;
      z-index: 1;
    }

    #imageContainer.visible {
      opacity: 1;
    }
    
    #imageContainer.darkened {
      /* Keep container visible but darken the image via filter */
      opacity: 1;
    }
    
    #imageContainer.darkened #storyImage {
      filter: brightness(0.35);
    }

    #storyImage {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: filter 0.8s ease-in-out;
    }
    
    #imageContainer.title-mode #storyImage {
      filter: brightness(1);
      object-fit: contain;
    }

    /* Title Display on Image */
    #titleOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 2;
      opacity: 0;
      transition: opacity 1.2s ease-in-out, transform 1.2s ease-out;
      padding: 30px 60px;
      background: linear-gradient(135deg, rgba(0,0,0,0.7) 0%, rgba(15,52,96,0.6) 100%);
      border-radius: 20px;
      border: 2px solid rgba(233,69,96,0.4);
      backdrop-filter: blur(8px);
      cursor: move;
    }
    
    #titleOverlay.dragging {
      transition: none;
      border-color: rgba(233,69,96,0.8);
      box-shadow: 0 0 30px rgba(233,69,96,0.6);
    }
    
    #titleOverlay.visible {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
      animation: titlePulse 3s ease-in-out infinite;
    }
    
    @keyframes titlePulse {
      0%, 100% { box-shadow: 0 0 30px rgba(233,69,96,0.3); }
      50% { box-shadow: 0 0 50px rgba(233,69,96,0.5); }
    }
    
    #titleOverlay h1 {
      color: var(--title-color, #e94560);
      font-size: calc(var(--title-font-size, 2.5em) * 1.6);
      font-weight: 700;
      text-shadow: 0 4px 15px rgba(0,0,0,1), 0 0 40px rgba(233,69,96,0.4);
      margin: 0;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    /* Text Overlay - Star Wars Scroll Container */
    #textOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      perspective: 600px;
      overflow: hidden;
      opacity: 0;
      transition: opacity 1s ease-in-out;
      z-index: 3;
      pointer-events: none;
      /* Subtle gradient from bottom for better readability */
      background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0.7) 100%);
    }

    #textOverlay.visible {
      opacity: 1;
    }

    #chapterTitle {
      display: none;
    }

    #chapterContent {
      color: var(--text-color, #ffffff);
      font-size: calc(var(--text-font-size, 1.3em) * 1.5);
      line-height: 2.0;
      text-shadow: 0 2px 8px rgba(0,0,0,0.95), 0 0 30px rgba(0,0,0,0.8);
      text-align: center;
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 85%;
      max-width: 1000px;
      max-height: 65%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      overflow: hidden;
      overflow-y: auto;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
      padding: 20px 0;
      cursor: move;
      pointer-events: auto; /* Override parent's pointer-events: none */
    }
    
    #chapterContent.dragging {
      transition: none;
      box-shadow: 0 0 30px rgba(233,69,96,0.5);
    }
    
    /* Hide scrollbar for Chrome/Safari/Opera */
    #chapterContent::-webkit-scrollbar {
      display: none;
    }

    /* Star Wars scroll mode - sentence container */
    #chapterContent.scroll-mode {
      gap: 1.5em;
    }
    
    /* Individual sentence styling - improved animations */
    .scroll-sentence {
      opacity: 0;
      transform: translateY(120px) scale(0.75);
      transition: all 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      width: 100%;
      min-height: 1.3em;
      padding: 8px 20px;
      border-radius: 8px;
      background: transparent;
    }
    
    .scroll-sentence.past {
      opacity: 0.15;
      transform: translateY(-100px) scale(0.7);
      filter: blur(2px);
    }
    
    .scroll-sentence.current {
      opacity: 1;
      transform: translateY(0) scale(1.05);
      font-weight: 600;
      color: #ffffff;
      text-shadow: 0 2px 10px rgba(0,0,0,1), 0 0 40px rgba(233, 69, 96, 0.3);
      filter: blur(0);
      background: linear-gradient(90deg, rgba(233,69,96,0.1) 0%, rgba(233,69,96,0.2) 50%, rgba(233,69,96,0.1) 100%);
      border-left: 3px solid var(--title-color, #e94560);
    }
    
    .scroll-sentence.future {
      opacity: 0.35;
      transform: translateY(60px) scale(0.85);
      filter: blur(0.3px);
    }
    
    .scroll-sentence.hidden {
      opacity: 0;
      transform: translateY(150px) scale(0.6);
    }
    
    /* Visibility control classes */
    .scroll-sentence.completely-hidden {
      display: none;
    }
    
    /* Immediate/Self-Reading Mode Styles */
    .immediate-title {
      color: var(--title-color, #e94560);
      font-size: calc(var(--title-font-size, 2.5em) * 1.2);
      font-weight: 700;
      text-shadow: 0 4px 15px rgba(0,0,0,1), 0 0 40px rgba(233,69,96,0.4);
      margin-bottom: 30px;
      text-align: center;
      letter-spacing: 1px;
      padding: 15px 25px;
      background: linear-gradient(135deg, rgba(0,0,0,0.5) 0%, rgba(15,52,96,0.4) 100%);
      border-radius: 15px;
      border: 2px solid rgba(233,69,96,0.3);
    }
    
    .immediate-content {
      color: var(--text-color, #ffffff);
      font-size: calc(var(--text-font-size, 1.3em) * 1.4);
      line-height: 1.9;
      text-shadow: 0 2px 8px rgba(0,0,0,0.95), 0 0 30px rgba(0,0,0,0.8);
      text-align: center;
      padding: 20px 30px;
      background: linear-gradient(135deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0.4) 100%);
      border-radius: 15px;
      max-height: 50vh;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(233,69,96,0.5) rgba(0,0,0,0.3);
    }
    
    .immediate-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .immediate-content::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
    }
    
    .immediate-content::-webkit-scrollbar-thumb {
      background: rgba(233,69,96,0.5);
      border-radius: 4px;
    }
    
    .immediate-content::-webkit-scrollbar-thumb:hover {
      background: rgba(233,69,96,0.7);
    }

    /* Voting Overlay */
    #votingOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 1100px;
      display: none;
      opacity: 0;
      transition: opacity 0.6s ease-in-out;
      z-index: 4;
      cursor: move;
    }

    #votingOverlay.active {
      display: block;
      opacity: 1;
    }
    
    #votingOverlay.dragging {
      transition: none;
      box-shadow: 0 0 40px rgba(233,69,96,0.6);
    }

    .voting-header {
      text-align: center;
      color: var(--title-color, #e94560);
      font-size: 2.2em;
      font-weight: bold;
      text-shadow: 0 2px 10px rgba(0,0,0,0.9);
      margin-bottom: 25px;
      background: linear-gradient(135deg, rgba(0,0,0,0.9) 0%, rgba(15,52,96,0.8) 100%);
      padding: 20px 30px;
      border-radius: 15px;
      border: 2px solid rgba(233,69,96,0.5);
      animation: pulseGlow 2s ease-in-out infinite;
    }
    
    @keyframes pulseGlow {
      0%, 100% { box-shadow: 0 0 20px rgba(233,69,96,0.3); }
      50% { box-shadow: 0 0 40px rgba(233,69,96,0.5); }
    }

    .choice-container {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .choice-item {
      background: linear-gradient(135deg, rgba(233,69,96,0.15) 0%, rgba(15,52,96,0.4) 50%, rgba(0,0,0,0.6) 100%);
      padding: 20px 25px;
      border-radius: 12px;
      border-left: 6px solid var(--title-color, #e94560);
      backdrop-filter: blur(15px);
      position: relative;
      overflow: hidden;
      animation: slideIn 0.5s ease-out;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .choice-item:hover {
      transform: translateX(5px);
      box-shadow: 0 5px 25px rgba(233,69,96,0.3);
    }

    .choice-item.winner {
      border-left: 6px solid #28a745;
      background: linear-gradient(135deg, rgba(40,167,69,0.3) 0%, rgba(15,52,96,0.4) 50%, rgba(0,0,0,0.6) 100%);
      animation: winnerPulse 1s ease-in-out infinite;
    }
    
    @keyframes winnerPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(40,167,69,0.4); }
      50% { box-shadow: 0 0 40px rgba(40,167,69,0.7); }
    }

    .choice-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .choice-letter {
      background: linear-gradient(135deg, var(--title-color, #e94560) 0%, #c73a52 100%);
      color: white;
      font-size: 1.4em;
      font-weight: bold;
      padding: 12px 22px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(233,69,96,0.5);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .choice-text {
      color: white;
      font-size: 1.3em;
      flex: 1;
      margin: 0 25px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.9);
      line-height: 1.4;
    }

    .choice-votes {
      color: white;
      font-size: 1.6em;
      font-weight: bold;
      min-width: 90px;
      text-align: right;
      text-shadow: 0 2px 4px rgba(0,0,0,0.9);
      font-variant-numeric: tabular-nums;
    }

    .vote-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 6px;
      background: linear-gradient(90deg, var(--title-color, #e94560) 0%, #ff6b8a 50%, #c73a52 100%);
      transition: width 0.6s ease-out;
      border-radius: 0 0 12px 0;
    }

    .timer-display {
      text-align: center;
      color: white;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 0 2px 8px rgba(0,0,0,0.9);
      margin-top: 25px;
      background: linear-gradient(135deg, rgba(0,0,0,0.85) 0%, rgba(15,52,96,0.7) 100%);
      padding: 15px 25px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .timer-display.urgent {
      color: var(--title-color, #e94560);
      animation: pulse 1s infinite;
    }

    /* Generating Overlay */
    #generatingOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      z-index: 5;
    }

    #generatingOverlay.active {
      display: block;
    }

    .spinner {
      width: 100px;
      height: 100px;
      border: 8px solid rgba(233,69,96,0.2);
      border-top: 8px solid var(--title-color, #e94560);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    .generating-media {
      margin-bottom: 12px;
      display: none;
    }
    
    .generating-media img,
    .generating-media video {
      max-width: 360px;
      max-height: 240px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    .generating-text {
      color: white;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }

    /* Animations */
    @keyframes fadeInSlide {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-50px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.05);
      }
    }

    /* Results Overlay */
    #resultsOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      background: rgba(0,0,0,0.9);
      padding: 50px;
      border-radius: 20px;
      border: 3px solid #28a745;
      z-index: 5;
    }

    #resultsOverlay.active {
      display: block;
      animation: zoomIn 0.5s ease-out;
    }

    .results-title {
      color: #28a745;
      font-size: 3em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      margin-bottom: 20px;
    }

    .results-choice {
      color: white;
      font-size: 2em;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Portrait orientation adjustments */
    body.portrait {
      width: var(--overlay-width, 1080px);
      height: var(--overlay-height, 1920px);
    }

    body.portrait #imageContainer {
      /* Full background, no adjustments needed */
    }

    body.portrait #textOverlay {
      /* Full screen overlay, no adjustments needed */
    }
    
    body.portrait #chapterContent {
      width: 90%;
      max-height: 60%;
    }
    
    body.portrait #titleOverlay h1 {
      font-size: calc(var(--title-font-size, 2.5em) * 1.2);
    }
  </style>
</head>
<body>
  <div id="storyOverlay">
    <!-- Image Container (background for title and chapter) -->
    <div id="imageContainer">
      <img id="storyImage" src="" alt="Story Image">
    </div>

    <!-- Title Overlay (shown first on image) -->
    <div id="titleOverlay" class="draggable" data-element="title">
      <h1 id="titleText"></h1>
    </div>

    <!-- Text Overlay (Star Wars scroll) -->
    <div id="textOverlay">
      <div id="chapterTitle"></div>
      <div id="chapterContent" class="draggable" data-element="content"></div>
    </div>
  </div>

  <!-- Voting Overlay -->
  <div id="votingOverlay" class="draggable" data-element="voting">
    <div class="voting-header">
      Vote Now! Type your choice in chat
    </div>
    <div class="choice-container" id="choiceContainer"></div>
    <div class="timer-display" id="timerDisplay">Time Remaining: --</div>
  </div>

  <!-- Generating Overlay -->
  <div id="generatingOverlay">
    <div class="spinner" id="generatingSpinner"></div>
    <div class="generating-media" id="generatingMedia">
      <img id="generatingImage" alt="Generating animation">
      <video id="generatingVideo" loop muted playsinline></video>
    </div>
    <div class="generating-text">Generating next chapter...</div>
  </div>

  <!-- Results Overlay -->
  <div id="resultsOverlay">
    <div class="results-title">Winner!</div>
    <div class="results-choice" id="winningChoice"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    
    let currentChapter = null;
    let votingActive = false;
    let voteTimer = null;
    let voteCounts = [];
    let config = null;
    let currentSentenceIndex = 0;
    let sentences = [];
    let sentenceTimer = null;
    let scrollingInProgress = false;
    
    // Configuration constants
    const MAX_VISIBLE_PAST_SENTENCES = 2; // How many past sentences to keep visible before hiding
    const SENTENCE_ANIMATION_DELAY_MS = 100; // Delay before animating sentence entrance
    
    // Overlay timing constants
    // NOTE: TEXT_OVERLAY_FADE_DURATION_MS must match CSS transition on #textOverlay
    //       See CSS rule: #textOverlay { transition: opacity 0.8s ease-in-out; }
    const TEXT_OVERLAY_FADE_DURATION_MS = 800; // Text overlay fade-out transition duration
    const TRANSITION_BUFFER_MS = 200; // Extra buffer for smooth transitions
    const VOTING_DISPLAY_DELAY_MS = TEXT_OVERLAY_FADE_DURATION_MS + TRANSITION_BUFFER_MS; // Total delay before showing voting

    // Load configuration and apply styles
    async function loadConfiguration() {
      try {
        const response = await fetch('/api/interactive-story/config');
        config = await response.json();
        applyConfiguration(config);
      } catch (error) {
        console.error('Failed to load configuration:', error);
        // Use defaults if config fails
        config = {
          overlayOrientation: 'landscape',
          overlayResolution: '1920x1080',
          overlayDisplayMode: 'scroll',
          overlayFontFamily: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
          overlayFontSize: 1.3,
          overlayTitleFontSize: 2.5,
          overlayTextColor: '#ffffff',
          overlayTitleColor: '#e94560',
          generatingAnimationMode: 'default',
          generatingAnimationUrl: '',
          overlayBackgroundGradient: 'linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.9) 30%, rgba(0,0,0,0.95) 100%)'
        };
        applyConfiguration(config);
      }
    }

    function applyConfiguration(cfg) {
      const root = document.documentElement;
      const body = document.body;
      
      // Parse resolution
      const [width, height] = cfg.overlayResolution.split('x').map(Number);
      
      // Apply orientation
      if (cfg.overlayOrientation === 'portrait') {
        body.classList.add('portrait');
        root.style.setProperty('--overlay-width', `${height}px`);
        root.style.setProperty('--overlay-height', `${width}px`);
      } else {
        body.classList.remove('portrait');
        root.style.setProperty('--overlay-width', `${width}px`);
        root.style.setProperty('--overlay-height', `${height}px`);
      }
      
      // Apply font and colors
      root.style.setProperty('--font-family', cfg.overlayFontFamily);
      root.style.setProperty('--text-font-size', `${cfg.overlayFontSize}em`);
      root.style.setProperty('--title-font-size', `${cfg.overlayTitleFontSize}em`);
      root.style.setProperty('--text-color', cfg.overlayTextColor);
      root.style.setProperty('--title-color', cfg.overlayTitleColor);
      root.style.setProperty('--overlay-background', cfg.overlayBackgroundGradient);
      
      // Apply display mode class
      const contentEl = document.getElementById('chapterContent');
      contentEl.classList.remove('sentence-mode', 'scroll-mode');
      
      if (cfg.overlayDisplayMode === 'sentence') {
        contentEl.classList.add('sentence-mode');
      } else if (cfg.overlayDisplayMode === 'scroll') {
        contentEl.classList.add('scroll-mode');
        // Calculate scroll duration based on estimated TTS time (approx 2-3 words/second)
        const avgWordsPerSecond = 2.5;
        const estimatedWords = 40; // Average for 30-50 word chapters
        const ttsDuration = estimatedWords / avgWordsPerSecond;
        root.style.setProperty('--scroll-duration', `${ttsDuration}s`);
      }
      
      applyGeneratingAnimation(cfg);
      
      console.log('Configuration applied:', cfg);
    }
    
    function applyGeneratingAnimation(cfg) {
      const mode = cfg.generatingAnimationMode || 'default';
      const url = cfg.generatingAnimationUrl || '';
      const spinner = document.getElementById('generatingSpinner');
      const media = document.getElementById('generatingMedia');
      const img = document.getElementById('generatingImage');
      const video = document.getElementById('generatingVideo');
      
      if (!spinner || !media || !img || !video) return;
      
      const lowerUrl = url.toLowerCase();
      const isVideo = lowerUrl.endsWith('.mp4') || lowerUrl.endsWith('.webm') || lowerUrl.endsWith('.mov');
      
      if (mode === 'custom' && url) {
        spinner.style.display = 'none';
        media.style.display = 'block';
        
        if (isVideo) {
          video.style.display = 'block';
          img.style.display = 'none';
          if (video.src !== url) {
            video.src = url;
            video.load();
          }
          video.play().catch(() => {});
        } else {
          img.style.display = 'block';
          img.src = url;
          video.style.display = 'none';
          video.pause();
          video.removeAttribute('src');
        }
      } else {
        spinner.style.display = 'block';
        media.style.display = 'none';
        img.removeAttribute('src');
        video.pause();
        video.removeAttribute('src');
      }
    }
    
    function restartGeneratingAnimationPlayback() {
      const video = document.getElementById('generatingVideo');
      if (video && video.style.display !== 'none') {
        video.currentTime = 0;
        video.play().catch(() => {});
      }
    }

    // ============================================
    // DRAGGABLE OVERLAY ELEMENTS
    // ============================================
    
    let overlayConfig = {
      positions: {}
    };
    
    let dragState = {
      isDragging: false,
      element: null,
      offsetX: 0,
      offsetY: 0,
      snapToGrid: false,
      gridSize: 20
    };
    
    /**
     * Initialize draggable functionality for overlay elements
     * Similar to quiz plugin implementation
     */
    function initDraggableElements() {
      // Load saved positions
      loadOverlayPositions();
      
      const draggableElements = document.querySelectorAll('.draggable');
      
      draggableElements.forEach(element => {
        element.addEventListener('mousedown', startDrag);
      });
      
      document.addEventListener('mousemove', doDrag);
      document.addEventListener('mouseup', stopDrag);
      
      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === 'g' || e.key === 'G') {
          dragState.snapToGrid = !dragState.snapToGrid;
          console.log('Snap to grid:', dragState.snapToGrid);
        }
        // Reset positions with 'r' key
        if (e.key === 'r' || e.key === 'R') {
          if (e.ctrlKey || e.metaKey) {
            resetOverlayPositions();
          }
        }
      });
      
      console.log('âœ… Draggable overlay elements initialized');
      console.log('ðŸ’¡ Tip: Hold Ctrl/Cmd and drag elements to reposition them');
      console.log('ðŸ’¡ Press "G" to toggle snap-to-grid, Ctrl+R to reset positions');
    }
    
    function startDrag(e) {
      // Only allow dragging with Ctrl/Cmd key to prevent accidental moves
      if (!e.ctrlKey && !e.metaKey) return;
      
      dragState.isDragging = true;
      dragState.element = e.currentTarget;
      
      const rect = dragState.element.getBoundingClientRect();
      dragState.offsetX = e.clientX - rect.left;
      dragState.offsetY = e.clientY - rect.top;
      
      dragState.element.classList.add('dragging');
      e.preventDefault();
    }
    
    function doDrag(e) {
      if (!dragState.isDragging || !dragState.element) return;
      
      let x = e.clientX - dragState.offsetX;
      let y = e.clientY - dragState.offsetY;
      
      // Snap to grid
      if (dragState.snapToGrid) {
        x = Math.round(x / dragState.gridSize) * dragState.gridSize;
        y = Math.round(y / dragState.gridSize) * dragState.gridSize;
      }
      
      // Apply position
      dragState.element.style.position = 'fixed';
      dragState.element.style.left = x + 'px';
      dragState.element.style.top = y + 'px';
      dragState.element.style.transform = 'none';
      
      e.preventDefault();
    }
    
    function stopDrag(e) {
      if (!dragState.isDragging) return;
      
      dragState.element.classList.remove('dragging');
      
      // Save position
      const elementType = dragState.element.getAttribute('data-element');
      const rect = dragState.element.getBoundingClientRect();
      
      if (!overlayConfig.positions) overlayConfig.positions = {};
      if (!overlayConfig.positions[elementType]) overlayConfig.positions[elementType] = {};
      
      overlayConfig.positions[elementType].top = rect.top;
      overlayConfig.positions[elementType].left = rect.left;
      
      // Send to server
      saveOverlayPositions();
      
      dragState.isDragging = false;
      dragState.element = null;
    }
    
    async function loadOverlayPositions() {
      try {
        const response = await fetch('/api/interactive-story/overlay-positions');
        if (!response.ok) {
          console.log('No saved overlay positions found, using defaults');
          return;
        }
        
        const data = await response.json();
        overlayConfig = data;
        
        // Apply saved positions
        if (overlayConfig.positions) {
          applyOverlayPositions();
        }
        
        console.log('âœ… Overlay positions loaded:', overlayConfig.positions);
      } catch (error) {
        console.error('Error loading overlay positions:', error);
      }
    }
    
    function applyOverlayPositions() {
      if (!overlayConfig.positions) return;
      
      // Apply title position
      if (overlayConfig.positions.title) {
        const titleEl = document.getElementById('titleOverlay');
        const pos = overlayConfig.positions.title;
        titleEl.style.position = 'fixed';
        titleEl.style.left = pos.left + 'px';
        titleEl.style.top = pos.top + 'px';
        titleEl.style.transform = 'none';
      }
      
      // Apply content position
      if (overlayConfig.positions.content) {
        const contentEl = document.getElementById('chapterContent');
        const pos = overlayConfig.positions.content;
        contentEl.style.position = 'fixed';
        contentEl.style.left = pos.left + 'px';
        contentEl.style.top = pos.top + 'px';
        contentEl.style.transform = 'none';
      }
      
      // Apply voting position
      if (overlayConfig.positions.voting) {
        const votingEl = document.getElementById('votingOverlay');
        const pos = overlayConfig.positions.voting;
        votingEl.style.position = 'fixed';
        votingEl.style.left = pos.left + 'px';
        votingEl.style.top = pos.top + 'px';
        votingEl.style.transform = 'none';
      }
    }
    
    async function saveOverlayPositions() {
      try {
        const response = await fetch('/api/interactive-story/overlay-positions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(overlayConfig)
        });
        
        if (!response.ok) {
          console.error('Failed to save overlay positions');
        } else {
          console.log('âœ… Overlay positions saved');
        }
      } catch (error) {
        console.error('Error saving overlay positions:', error);
      }
    }
    
    async function resetOverlayPositions() {
      overlayConfig.positions = {};
      
      // Reset styles to defaults
      const titleEl = document.getElementById('titleOverlay');
      const contentEl = document.getElementById('chapterContent');
      const votingEl = document.getElementById('votingOverlay');
      
      [titleEl, contentEl, votingEl].forEach(el => {
        if (el) {
          el.style.position = '';
          el.style.left = '';
          el.style.top = '';
          el.style.transform = '';
        }
      });
      
      await saveOverlayPositions();
      console.log('âœ… Overlay positions reset to defaults');
    }

    // Handle chapter ready - show title first
    socket.on('story:chapter-ready', (chapter) => {
      currentChapter = chapter;
      scrollingInProgress = false;
      sentences = [];
      currentSentenceIndex = 0;
      
      // Prepare the overlay for title phase
      document.getElementById('generatingOverlay').classList.remove('active');
      const overlay = document.getElementById('storyOverlay');
      overlay.classList.add('active');
      document.getElementById('textOverlay').classList.remove('visible');
      
      const titleOverlay = document.getElementById('titleOverlay');
      const titleText = document.getElementById('titleText');
      titleOverlay.classList.remove('visible');
      titleText.textContent = chapter.title;
      
      const contentEl = document.getElementById('chapterContent');
      contentEl.textContent = '';
      
      // Update image if available
      const imageContainer = document.getElementById('imageContainer');
      const storyImage = document.getElementById('storyImage');
      
      if (chapter.imagePath) {
        // imagePath now contains just the filename (not full path)
        storyImage.src = `/api/interactive-story/image/${chapter.imagePath}`;
        
        // Show image in title mode (bright, centered)
        imageContainer.classList.add('title-mode');
        imageContainer.classList.remove('darkened');
        imageContainer.classList.add('visible');
      } else {
        imageContainer.classList.remove('visible');
        imageContainer.classList.remove('darkened');
        imageContainer.classList.remove('title-mode');
      }
    });
    
    // Title display phase after image preview
    socket.on('story:chapter-title-phase', (data) => {
      const overlay = document.getElementById('storyOverlay');
      overlay.classList.add('active');
      
      const titleOverlay = document.getElementById('titleOverlay');
      const titleText = document.getElementById('titleText');
      titleText.textContent = data.title || (currentChapter ? currentChapter.title : '');
      titleOverlay.classList.add('visible');
      
      const imageContainer = document.getElementById('imageContainer');
      imageContainer.classList.remove('title-mode');
      imageContainer.classList.add('darkened');
      document.getElementById('textOverlay').classList.remove('visible');
    });
    
    // Handle progressive TTS sentence display
    // Handle TTS start - prepare for progressive sentence display
    socket.on('story:chapter-tts-start', (data) => {
      console.log('TTS started - preparing for progressive sentence display', data);
      
      scrollingInProgress = true;
      currentSentenceIndex = 0;
      sentences = [];
      
      // Fade out title overlay
      const titleOverlay = document.getElementById('titleOverlay');
      titleOverlay.classList.remove('visible');
      
      // Darken image and make it background
      const imageContainer = document.getElementById('imageContainer');
      setTimeout(() => {
        imageContainer.classList.remove('title-mode');
        imageContainer.classList.add('darkened');
        
        // Prepare content for Star Wars scroll
        const contentEl = document.getElementById('chapterContent');
        contentEl.classList.add('scroll-mode');
        // Clear content safely (compatible with all browsers)
        contentEl.textContent = '';
        
        // Show text overlay
        document.getElementById('textOverlay').classList.add('visible');
      }, 400);
    });
    
    // Handle individual sentences arriving during TTS playback (Star Wars scroll effect)
    socket.on('story:chapter-sentence', (data) => {
      console.log(`Sentence ${data.index + 1}/${data.total}:`, data.sentence);
      
      if (!scrollingInProgress) return;
      
      const contentEl = document.getElementById('chapterContent');
      
      // Create sentence element
      const sentenceEl = document.createElement('div');
      sentenceEl.className = 'scroll-sentence hidden';
      sentenceEl.textContent = data.sentence;
      
      // Add to container
      contentEl.appendChild(sentenceEl);
      sentences.push(sentenceEl);
      
      // Animate entrance after brief delay
      setTimeout(() => {
        updateSentenceStates(data.index);
      }, SENTENCE_ANIMATION_DELAY_MS);
    });
    
    // Update sentence states based on current index
    function updateSentenceStates(currentIndex) {
      sentences.forEach((sentenceEl, index) => {
        // Remove all state classes
        sentenceEl.classList.remove('past', 'current', 'future', 'hidden', 'completely-hidden');
        
        if (index < currentIndex - MAX_VISIBLE_PAST_SENTENCES) {
          // Very old sentences - remove from view completely using CSS class
          sentenceEl.classList.add('completely-hidden');
        } else if (index < currentIndex) {
          // Past sentences - fade out upwards
          sentenceEl.classList.add('past');
        } else if (index === currentIndex) {
          // Current sentence - fully visible and prominent
          sentenceEl.classList.add('current');
        } else if (index === currentIndex + 1) {
          // Next sentence - slightly visible
          sentenceEl.classList.add('future');
        } else {
          // Future sentences - hidden
          sentenceEl.classList.add('hidden');
        }
      });
      
      currentSentenceIndex = currentIndex;
    }
    
    // Handle TTS complete (ready for voting)
    socket.on('story:chapter-tts-complete', (data) => {
      console.log('TTS complete for chapter', data.chapterNumber);
      scrollingInProgress = false;
      
      // Keep last sentence visible as current (not marked as past)
      if (sentences.length > 0) {
        updateSentenceStates(sentences.length - 1);
      }
      
      // Ready for voting to start - text will fade out when voting overlay appears
    });
    
    // Handle immediate chapter display (fallback when TTS disabled)
    socket.on('story:chapter-display', (data) => {
      console.log('ðŸ“– Chapter display event received:', data.mode, data.chapter?.title);
      
      if (data.mode === 'immediate' && data.chapter) {
        // Hide title overlay
        const titleOverlay = document.getElementById('titleOverlay');
        titleOverlay.classList.remove('visible');
        
        // Setup image
        const imageContainer = document.getElementById('imageContainer');
        imageContainer.classList.add('darkened');
        imageContainer.classList.remove('title-mode');
        
        // Make sure story overlay is active
        const overlay = document.getElementById('storyOverlay');
        overlay.classList.add('active');
        
        // Display full chapter content for self-reading
        displayImmediateChapter(data.chapter);
      }
    });

    // Handle voting started
    socket.on('story:voting-started', (data) => {
      votingActive = true;
      
      // STEP 1: Hide text overlay first
      document.getElementById('textOverlay').classList.remove('visible');
      
      // Only display voting if we have choices (not for final chapter where choices would be null or empty)
      if (data.choices && data.choices.length > 0) {
        voteCounts = new Array(data.choices.length).fill(0);
        
        // STEP 2: Wait for text overlay fade-out transition to complete before showing voting
        setTimeout(() => {
          displayVoting(data.choices, data.duration, data.voteKeywordPattern || '!letter');
        }, VOTING_DISPLAY_DELAY_MS);
      }
    });

    // Handle vote updates
    socket.on('story:vote-update', (data) => {
      voteCounts = data.voteCounts;
      updateVoteDisplay();
    });

    // Handle voting ended
    socket.on('story:voting-ended', (results) => {
      votingActive = false;
      showResults(results);
      
      // Hide voting after 3 seconds
      setTimeout(() => {
        document.getElementById('votingOverlay').classList.remove('active');
        document.getElementById('resultsOverlay').classList.remove('active');
      }, 3000);
    });

    // Handle generation started
    socket.on('story:generation-started', () => {
      if (config) {
        applyGeneratingAnimation(config);
        restartGeneratingAnimationPlayback();
      }
      document.getElementById('generatingOverlay').classList.add('active');
      document.getElementById('storyOverlay').classList.remove('active');
      document.getElementById('votingOverlay').classList.remove('active');
      document.getElementById('titleOverlay').classList.remove('visible');
      document.getElementById('textOverlay').classList.remove('visible');
    });

    // Handle image updated
    socket.on('story:image-updated', (data) => {
      if (currentChapter && data.imagePath) {
        // imagePath now contains just the filename (not full path)
        document.getElementById('storyImage').src = `/api/interactive-story/image/${data.imagePath}`;
      }
    });

    // Handle image generation failed
    socket.on('story:image-generation-failed', (data) => {
      console.warn('âš ï¸ Image generation failed:', data.message);
      // Story continues without image - no action needed on overlay
    });

    // Handle story ended - hide all overlays
    socket.on('story:ended', (data) => {
      console.log('Story ended, hiding overlay:', data);
      
      // Hide all overlays with fade out
      document.getElementById('storyOverlay').classList.remove('active');
      document.getElementById('votingOverlay').classList.remove('active');
      document.getElementById('resultsOverlay').classList.remove('active');
      document.getElementById('generatingOverlay').classList.remove('active');
      document.getElementById('textOverlay').classList.remove('visible');
      document.getElementById('titleOverlay').classList.remove('visible');
      const imageContainer = document.getElementById('imageContainer');
      imageContainer.classList.remove('visible');
      imageContainer.classList.remove('darkened');
      imageContainer.classList.remove('title-mode');
      
      // Reset state
      currentChapter = null;
      votingActive = false;
      scrollingInProgress = false;
      sentences = [];
      currentSentenceIndex = 0;
      
      if (voteTimer) {
        clearInterval(voteTimer);
        voteTimer = null;
      }
      
      if (sentenceTimer) {
        clearInterval(sentenceTimer);
        sentenceTimer = null;
      }
    });

    function splitIntoSentences(text) {
      // Split on periods, exclamation marks, and question marks followed by space or end
      return text.match(/[^.!?]+[.!?]+/g) || [text];
    }

    function displayChapter(chapter) {
      // Hide generating overlay
      document.getElementById('generatingOverlay').classList.remove('active');
      
      // Show story overlay
      const overlay = document.getElementById('storyOverlay');
      overlay.classList.add('active');
      
      // Update title
      document.getElementById('chapterTitle').textContent = chapter.title;
      
      // Update image if available
      const imageContainer = document.getElementById('imageContainer');
      const storyImage = document.getElementById('storyImage');
      
      if (chapter.imagePath) {
        const filename = chapter.imagePath.split('/').pop();
        storyImage.src = `/api/interactive-story/image/${filename}`;
        imageContainer.classList.add('visible');
      } else {
        imageContainer.classList.remove('visible');
      }
      
      // Display content based on mode
      if (config && config.overlayDisplayMode === 'sentence') {
        displaySentenceBySentence(chapter.content);
      } else if (config && config.overlayDisplayMode === 'scroll') {
        displayScrollingChapter(chapter.content);
      } else {
        displayFullChapter(chapter.content);
      }
      
      // Show text overlay
      document.getElementById('textOverlay').classList.add('visible');
    }

    function displayFullChapter(content) {
      // Clear any sentence timer
      if (sentenceTimer) {
        clearInterval(sentenceTimer);
        sentenceTimer = null;
      }
      
      const contentEl = document.getElementById('chapterContent');
      contentEl.classList.remove('scroll-mode');
      contentEl.textContent = content;
    }

    function displayScrollingChapter(content) {
      // Clear any sentence timer
      if (sentenceTimer) {
        clearInterval(sentenceTimer);
        sentenceTimer = null;
      }
      
      const contentEl = document.getElementById('chapterContent');
      contentEl.classList.add('scroll-mode');
      
      // Reset animation by removing and re-adding the class
      contentEl.style.animation = 'none';
      setTimeout(() => {
        contentEl.style.animation = '';
        contentEl.textContent = content;
      }, 10);
    }

    function displaySentenceBySentence(content) {
      // Split content into sentences
      sentences = splitIntoSentences(content);
      currentSentenceIndex = 0;
      
      // Clear any existing timer
      if (sentenceTimer) {
        clearInterval(sentenceTimer);
      }
      
      // Display first sentence
      const contentEl = document.getElementById('chapterContent');
      contentEl.textContent = sentences[0] || '';
      
      // Set up timer to show sentences one by one (every 5 seconds)
      if (sentences.length > 1) {
        sentenceTimer = setInterval(() => {
          currentSentenceIndex++;
          if (currentSentenceIndex < sentences.length) {
            // Using textContent for security (prevents XSS from LLM output)
            // join(' ') maintains proper sentence spacing
            contentEl.textContent = sentences.slice(0, currentSentenceIndex + 1).join(' ');
          } else {
            clearInterval(sentenceTimer);
            sentenceTimer = null;
          }
        }, 5000);
      }
    }
    
    /**
     * Display chapter immediately for self-reading mode (when TTS is disabled)
     * Shows full content with proper styling for reading
     */
    function displayImmediateChapter(chapter) {
      console.log('ðŸ“– Displaying chapter immediately for self-reading:', chapter.title);
      
      // Hide generating overlay
      document.getElementById('generatingOverlay').classList.remove('active');
      
      // Show story overlay
      const overlay = document.getElementById('storyOverlay');
      overlay.classList.add('active');
      
      // Update image if available
      const imageContainer = document.getElementById('imageContainer');
      const storyImage = document.getElementById('storyImage');
      
      if (chapter.imagePath) {
        // Handle both filename-only and full path formats
        const filename = chapter.imagePath.includes('/') || chapter.imagePath.includes('\\') 
          ? chapter.imagePath.split(/[/\\]/).pop() 
          : chapter.imagePath;
        storyImage.src = `/api/interactive-story/image/${filename}`;
        imageContainer.classList.add('visible');
        imageContainer.classList.add('darkened');
        imageContainer.classList.remove('title-mode');
      } else {
        imageContainer.classList.add('visible');
        imageContainer.classList.add('darkened');
        imageContainer.classList.remove('title-mode');
      }
      
      // Clear any sentence timer
      if (sentenceTimer) {
        clearInterval(sentenceTimer);
        sentenceTimer = null;
      }
      
      // Show full content with title for self-reading
      const contentEl = document.getElementById('chapterContent');
      contentEl.classList.remove('scroll-mode');
      
      // Create reading-friendly display with title and full content
      contentEl.innerHTML = '';
      
      // Add chapter title
      const titleEl = document.createElement('div');
      titleEl.className = 'immediate-title';
      titleEl.textContent = chapter.title;
      contentEl.appendChild(titleEl);
      
      // Add content text
      const textEl = document.createElement('div');
      textEl.className = 'immediate-content';
      textEl.textContent = chapter.content;
      contentEl.appendChild(textEl);
      
      // Show text overlay
      document.getElementById('textOverlay').classList.add('visible');
      
      console.log('âœ… Chapter displayed for self-reading');
    }

    function displayVoting(choices, duration, voteKeywordPattern = '!letter') {
      // Clear sentence timer when voting starts
      if (sentenceTimer) {
        clearInterval(sentenceTimer);
        sentenceTimer = null;
      }
      
      const votingOverlay = document.getElementById('votingOverlay');
      const choiceContainer = document.getElementById('choiceContainer');
      
      choiceContainer.innerHTML = '';
      
      choices.forEach((choice, index) => {
        const voteKeyword = getVoteKeywordForIndex(index, voteKeywordPattern);
        const choiceDiv = document.createElement('div');
        choiceDiv.className = 'choice-item';
        choiceDiv.innerHTML = `
          <div class="choice-header">
            <div class="choice-letter">${voteKeyword}</div>
            <div class="choice-text">${choice}</div>
            <div class="choice-votes" id="votes-${index}">0</div>
          </div>
          <div class="vote-bar" id="bar-${index}" style="width: 0%"></div>
        `;
        choiceContainer.appendChild(choiceDiv);
      });
      
      votingOverlay.classList.add('active');
      
      // Start timer
      startVoteTimer(duration);
    }
    
    /**
     * Get vote keyword for a specific choice index based on pattern
     * @param {number} index - Choice index (0-based)
     * @param {string} pattern - Vote keyword pattern
     * @returns {string} - Vote keyword
     */
    function getVoteKeywordForIndex(index, pattern) {
      switch (pattern) {
        case '!letter':
          return `!${String.fromCharCode('a'.charCodeAt(0) + index)}`;
        
        case 'letter':
          return String.fromCharCode('A'.charCodeAt(0) + index);
        
        case 'number':
          return String(index + 1);
        
        case 'antwort':
          return `Antwort ${index + 1}`;
        
        case 'answer':
          return `Answer ${index + 1}`;
        
        default:
          return `!${String.fromCharCode('a'.charCodeAt(0) + index)}`;
      }
    }

    function updateVoteDisplay() {
      if (!votingActive) return;
      
      const maxVotes = Math.max(...voteCounts, 1);
      
      voteCounts.forEach((count, index) => {
        const votesEl = document.getElementById(`votes-${index}`);
        const barEl = document.getElementById(`bar-${index}`);
        
        if (votesEl) votesEl.textContent = count;
        if (barEl) {
          const percentage = (count / maxVotes) * 100;
          barEl.style.width = `${percentage}%`;
        }
      });
    }

    function startVoteTimer(duration) {
      const timerDisplay = document.getElementById('timerDisplay');
      let timeLeft = duration;
      
      if (voteTimer) clearInterval(voteTimer);
      
      voteTimer = setInterval(() => {
        timeLeft--;
        
        if (timeLeft <= 0) {
          clearInterval(voteTimer);
          timerDisplay.textContent = 'Voting Ended!';
        } else {
          timerDisplay.textContent = `Time Remaining: ${timeLeft}s`;
          
          if (timeLeft <= 10) {
            timerDisplay.classList.add('urgent');
          } else {
            timerDisplay.classList.remove('urgent');
          }
        }
      }, 1000);
    }

    function showResults(results) {
      // Highlight winner in voting overlay
      const winnerEl = document.querySelector(`.choice-item:nth-child(${results.winnerIndex + 1})`);
      if (winnerEl) {
        winnerEl.classList.add('winner');
      }
      
      // Show results overlay
      document.getElementById('winningChoice').textContent = results.winnerText;
      document.getElementById('resultsOverlay').classList.add('active');
    }

    // Relay TTS playback ended event back to server
    // This is needed because plugin-to-plugin communication requires 
    // client relay: TTS plugin â†’ client â†’ back to server â†’ interactive-story plugin
    socket.on('tts:playback:ended', (data) => {
      console.log('TTS playback ended, relaying to server:', data);
      // Re-emit the event to the server so other plugins can receive it
      socket.emit('tts:playback:ended', data);
    });

    // Socket connection monitoring
    socket.on('connect', () => {
      console.log('âœ… Socket.io connected to server');
    });

    socket.on('disconnect', (reason) => {
      console.warn('âš ï¸ Socket.io disconnected:', reason);
    });

    socket.on('connect_error', (error) => {
      console.error('âŒ Socket.io connection error:', error);
    });
    
    // Listen for real-time configuration updates
    socket.on('story:config-updated', (updatedConfig) => {
      console.log('ðŸ“¡ Configuration updated, applying changes...', updatedConfig);
      // Merge with current config and reapply
      if (config) {
        Object.assign(config, updatedConfig);
        applyConfiguration(config);
        console.log('âœ… Configuration applied successfully');
      }
    });

    // Initialize
    loadConfiguration().then(() => {
      console.log('âœ… Interactive Story Overlay loaded and configured successfully');
      console.log('ðŸ“º Overlay ready - waiting for story to start...');
      
      // Initialize draggable elements
      initDraggableElements();
    }).catch((error) => {
      console.error('âŒ Failed to initialize overlay:', error);
    });
  </script>
</body>
</html>
