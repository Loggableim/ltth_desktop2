<!DOCTYPE html>
<html lang="en" data-theme="night">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-i18n="game_engine.title">LTTH Game Engine - Admin Panel</title>
  <link rel="stylesheet" href="/css/themes.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--color-bg-primary, #1a1a2e);
      color: var(--color-text-primary, #eee);
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
    }

    /* Widescreen responsive layout */
    @media (min-width: 1920px) {
      .container {
        max-width: 1800px;
      }
    }

    h1 {
      color: var(--brand-primary, #4CAF50);
      margin-bottom: 10px;
    }

    h2 {
      color: var(--color-accent-primary, #64B5F6);
      margin-top: 30px;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--color-accent-primary, #64B5F6);
      padding-bottom: 5px;
    }

    h3 {
      color: var(--color-accent-warning, #FFC107);
      margin-top: 20px;
      margin-bottom: 10px;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid var(--color-border, #333);
      flex-wrap: wrap;
    }

    .tab {
      padding: 12px 24px;
      background: var(--color-bg-secondary, #2a2a3e);
      border: none;
      color: var(--color-text-primary, #eee);
      cursor: pointer;
      font-size: 16px;
      border-radius: 8px 8px 0 0;
      transition: all 0.3s;
    }

    .tab:hover {
      background: var(--color-bg-hover, #3a3a4e);
    }

    .tab.active {
      background: var(--brand-primary, #4CAF50);
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
      /* Feature #2: Tab fade-in animation */
      animation: fadeIn 0.3s ease-out;
    }

    /* Feature #2: Animation Keyframes */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideInRight {
      from {
        transform: translateX(20px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    @keyframes bounce {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-10px);
      }
    }

    .card {
      background: var(--color-bg-card, #2a2a3e);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: var(--shadow-md, 0 4px 6px rgba(0, 0, 0, 0.3));
      border: 1px solid var(--color-border, transparent);
      /* Feature #2: Card hover animation */
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
    }

    .form-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      color: var(--color-text-secondary, #aaa);
      font-size: 14px;
    }

    input[type="text"],
    input[type="number"],
    input[type="color"],
    select {
      width: 100%;
      padding: 10px;
      background: var(--color-input-bg, #1a1a2e);
      border: 1px solid var(--color-input-border, #444);
      border-radius: 5px;
      color: var(--color-input-text, #eee);
      font-size: 14px;
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    button {
      padding: 12px 24px;
      background: var(--brand-primary, #4CAF50);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      /* Feature #2: Button animations */
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    button:hover {
      background: var(--brand-primary-hover, #45a049);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    button:active {
      /* Feature #2: Button press animation */
      transform: scale(0.98) translateY(-1px);
    }

    /* Feature #2: Ripple effect on button click */
    button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:focus::after {
      width: 300px;
      height: 300px;
    }

    button.secondary {
      background: var(--color-accent-primary, #64B5F6);
    }

    button.secondary:hover {
      background: var(--color-accent-primary, #42A5F5);
      filter: brightness(0.9);
    }

    button.danger {
      background: var(--color-accent-danger, #f44336);
    }

    button.danger:hover {
      background: var(--color-accent-danger, #da190b);
      filter: brightness(0.9);
    }

    .color-picker {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .color-preview {
      width: 40px;
      height: 40px;
      border-radius: 5px;
      border: 2px solid #444;
    }

    #active-game {
      display: none;
    }

    #active-game.show {
      display: block;
    }

    .game-board-preview {
      display: grid;
      grid-template-columns: repeat(7, 50px);
      gap: 5px;
      margin: 20px 0;
    }

    .board-cell-preview {
      width: 50px;
      height: 50px;
      background: var(--color-bg-primary, #1a1a2e);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s;
      border: 1px solid var(--color-border, #444);
    }

    .board-cell-preview:hover {
      transform: scale(1.1);
    }

    .board-cell-preview.filled {
      cursor: not-allowed;
    }

    .piece-preview {
      width: 45px;
      height: 45px;
      border-radius: 50%;
    }

    .column-button {
      margin: 5px;
      padding: 20px 30px;
      font-size: 24px;
      font-weight: bold;
    }

    .status-bar {
      background: #3a3a4e;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .stat-card {
      background: #3a3a4e;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 32px;
      font-weight: bold;
      color: #4CAF50;
    }

    .stat-label {
      font-size: 14px;
      color: #aaa;
      margin-top: 5px;
    }

    .trigger-list {
      margin-top: 15px;
    }

    .trigger-item {
      background: #3a3a4e;
      padding: 10px 15px;
      border-radius: 5px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .success-message {
      background: #4CAF50;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      margin-bottom: 15px;
      display: none;
      /* Feature #2: Success animation */
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease-out;
    }

    .success-message.show {
      display: block;
      opacity: 1;
      transform: translateY(0);
      animation: bounce 0.6s ease-out;
    }

    .error-message {
      background: #f44336;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      margin-bottom: 15px;
      display: none;
      /* Feature #2: Error animation */
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease-out;
    }

    .error-message.show {
      display: block;
      opacity: 1;
      transform: translateY(0);
      animation: shake 0.5s ease-out;
    }

    /* Feature #2: Loading States */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spinner 0.8s linear infinite;
      vertical-align: middle;
      margin-left: 10px;
    }

    @keyframes spinner {
      to {
        transform: rotate(360deg);
      }
    }

    .skeleton {
      background: linear-gradient(
        90deg,
        var(--color-bg-secondary) 25%,
        var(--color-bg-hover) 50%,
        var(--color-bg-secondary) 75%
      );
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s ease-in-out infinite;
      border-radius: 4px;
    }

    @keyframes skeleton-loading {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }

    .skeleton-text {
      height: 16px;
      margin-bottom: 8px;
    }

    .skeleton-title {
      height: 24px;
      width: 60%;
      margin-bottom: 12px;
    }

    /* Feature #2: List item stagger animation */
    .stats-table tbody tr {
      animation: fadeIn 0.3s ease-out backwards;
    }

    .stats-table tbody tr:nth-child(1) { animation-delay: 0.05s; }
    .stats-table tbody tr:nth-child(2) { animation-delay: 0.1s; }
    .stats-table tbody tr:nth-child(3) { animation-delay: 0.15s; }
    .stats-table tbody tr:nth-child(4) { animation-delay: 0.2s; }
    .stats-table tbody tr:nth-child(5) { animation-delay: 0.25s; }
    .stats-table tbody tr:nth-child(6) { animation-delay: 0.3s; }
    .stats-table tbody tr:nth-child(7) { animation-delay: 0.35s; }
    .stats-table tbody tr:nth-child(8) { animation-delay: 0.4s; }
    .stats-table tbody tr:nth-child(9) { animation-delay: 0.45s; }
    .stats-table tbody tr:nth-child(10) { animation-delay: 0.5s; }

    /* Feature #2: Input focus animation */
    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--brand-primary);
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
      transform: scale(1.01);
    }

    /* Gift Catalog Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal-content {
      background: #2a2a3e;
      border-radius: 15px;
      padding: 30px;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-header h3 {
      margin: 0;
      color: #4CAF50;
    }

    .modal-close {
      background: #f44336;
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-close:hover {
      background: #d32f2f;
    }

    .gift-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .gift-card {
      background: #3a3a4e;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
    }

    .gift-card:hover {
      background: #4a4a5e;
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .gift-card.selected {
      border-color: #4CAF50;
      background: #3a5a3e;
    }

    .gift-card img {
      width: 80px;
      height: 80px;
      object-fit: contain;
      margin-bottom: 10px;
    }

    .gift-placeholder {
      width: 80px;
      height: 80px;
      margin: 0 auto 10px;
      font-size: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .gift-name {
      font-size: 14px;
      color: #eee;
      word-break: break-word;
    }

    .gift-id {
      font-size: 11px;
      color: #888;
      margin-top: 5px;
    }

    .catalog-info {
      text-align: center;
      padding: 15px;
      background: #3a3a4e;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    /* Theme Toggle Styles (Feature #1) */
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .header-left {
      flex: 1;
      min-width: 300px;
    }

    .header-left h1 {
      margin-bottom: 5px;
    }

    .header-left p {
      color: var(--color-text-secondary);
      font-size: 14px;
    }

    .theme-toggle-container {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--color-bg-card);
      padding: 8px 15px;
      border-radius: 20px;
      border: 1px solid var(--color-border);
    }

    .theme-toggle-label {
      font-size: 13px;
      color: var(--color-text-secondary);
      white-space: nowrap;
    }

    .theme-toggle-btn {
      background: var(--color-bg-secondary);
      border: 1px solid var(--color-border);
      color: var(--color-text-primary);
      padding: 6px 12px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
    }

    .theme-toggle-btn:hover {
      background: var(--color-bg-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .theme-toggle-btn.active {
      background: var(--brand-primary);
      border-color: var(--brand-primary);
      color: white;
    }

    .theme-icon {
      font-size: 16px;
    }
  </style>
  <script src="/game-engine/assets/theme-manager.js"></script>
</head>
<body>
  <div class="container">
    <div class="header-container">
      <div class="header-left">
        <h1>üéÆ LTTH Game Engine</h1>
        <p>Interaktive Spiele f√ºr TikTok LIVE Streams</p>
      </div>
      <div class="theme-toggle-container">
        <span class="theme-toggle-label">Theme:</span>
        <button class="theme-toggle-btn" id="theme-dark" data-theme="dark">
          <span class="theme-icon">üåô</span>
          <span>Dark</span>
        </button>
        <button class="theme-toggle-btn" id="theme-light" data-theme="light">
          <span class="theme-icon">‚òÄÔ∏è</span>
          <span>Light</span>
        </button>
        <button class="theme-toggle-btn" id="theme-system" data-theme="system">
          <span class="theme-icon">üñ•Ô∏è</span>
          <span>System</span>
        </button>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="active-game">Aktives Spiel</button>
      <button class="tab" data-tab="manual-mode">üß™ Manual Mode</button>
      <button class="tab" data-tab="connect4">Connect4</button>
      <button class="tab" data-tab="chess">‚ôüÔ∏è Blitzschach</button>
      <button class="tab" data-tab="plinko">üé∞ Plinko</button>
      <button class="tab" data-tab="plinko-test">üß™ Plinko Test</button>
      <button class="tab" data-tab="wheel">üé° Gl√ºcksrad</button>
      <button class="tab" data-tab="overlays">OBS Overlays</button>
      <button class="tab" data-tab="triggers">Trigger</button>
      <button class="tab" data-tab="xp-rewards">XP-Belohnungen</button>
      <button class="tab" data-tab="elo">ELO System</button>
      <button class="tab" data-tab="media">Media</button>
      <button class="tab" data-tab="stats">Statistiken</button>
    </div>

    <div class="success-message" id="success-message"></div>
    <div class="error-message" id="error-message"></div>

    <!-- Active Game Tab -->
    <div class="tab-content active" id="tab-active-game">
      <div id="no-game" class="card">
        <h3>Kein aktives Spiel</h3>
        <p>Warte darauf, dass ein Zuschauer ein Geschenk sendet oder einen Befehl eingibt, um ein Spiel zu starten.</p>
      </div>

      <div id="active-game">
        <div class="status-bar">
          <h3>Connect4 Spiel l√§uft</h3>
          <p id="game-status">Warte auf Zug...</p>
        </div>

        <div class="card">
          <h3>Dein Zug - W√§hle eine Spalte:</h3>
          <div style="text-align: center;">
            <button class="column-button" data-column="A">A</button>
            <button class="column-button" data-column="B">B</button>
            <button class="column-button" data-column="C">C</button>
            <button class="column-button" data-column="D">D</button>
            <button class="column-button" data-column="E">E</button>
            <button class="column-button" data-column="F">F</button>
            <button class="column-button" data-column="G">G</button>
          </div>
        </div>

        <div class="card">
          <h3>Spielfeld</h3>
          <div id="board-preview"></div>
        </div>

        <div class="card">
          <button class="danger" id="cancelGameBtn">Spiel abbrechen</button>
        </div>
      </div>
    </div>

    <!-- Manual Mode Tab -->
    <div class="tab-content" id="tab-manual-mode">
      <div class="card">
        <h2>üß™ Manual Mode - Offline Testing</h2>
        <p>Starte ein Test-Spiel ohne TikTok-Verbindung zum Testen und Entwickeln.</p>
      </div>

      <div class="card">
        <h3>Neues Test-Spiel starten</h3>
        
        <div class="form-group">
          <label>Spieltyp:</label>
          <select id="manual-game-type">
            <option value="connect4">Connect4 (Vier Gewinnt)</option>
          </select>
        </div>

        <div class="form-group">
          <label>Gegner-Typ:</label>
          <select id="manual-opponent-type">
            <option value="manual">Manuell (Du steuerst beide Spieler)</option>
            <option value="bot">Bot (Zufall)</option>
          </select>
        </div>

        <div class="form-group">
          <label>Spieler 1 Name:</label>
          <input type="text" id="manual-player1-name" value="Test Spieler 1" placeholder="Name des ersten Spielers">
        </div>

        <div class="form-group">
          <label>Spieler 2 Name:</label>
          <input type="text" id="manual-player2-name" value="Test Spieler 2" placeholder="Name des zweiten Spielers">
        </div>

        <button id="start-manual-game" class="btn">üéÆ Test-Spiel starten</button>
      </div>

      <!-- Manual Game Control -->
      <div id="manual-game-controls" style="display: none;">
        <div class="card">
          <h3>üéÆ Test-Spiel aktiv</h3>
          <div id="manual-game-info" class="status-bar">
            <p><strong>Spiel ID:</strong> <span id="manual-session-id">-</span></p>
            <p><strong>Aktueller Spieler:</strong> <span id="manual-current-player">-</span></p>
            <p><strong>Status:</strong> <span id="manual-game-status">L√§uft</span></p>
          </div>
        </div>

        <div class="card">
          <h3>Spieler 1 Zug</h3>
          <p>W√§hle eine Spalte f√ºr Spieler 1:</p>
          <div style="text-align: center; margin: 10px 0;">
            <button class="column-button manual-move" data-player="1" data-column="A">A</button>
            <button class="column-button manual-move" data-player="1" data-column="B">B</button>
            <button class="column-button manual-move" data-player="1" data-column="C">C</button>
            <button class="column-button manual-move" data-player="1" data-column="D">D</button>
            <button class="column-button manual-move" data-player="1" data-column="E">E</button>
            <button class="column-button manual-move" data-player="1" data-column="F">F</button>
            <button class="column-button manual-move" data-player="1" data-column="G">G</button>
          </div>
        </div>

        <div class="card">
          <h3>Spieler 2 Zug</h3>
          <p>W√§hle eine Spalte f√ºr Spieler 2:</p>
          <div style="text-align: center; margin: 10px 0;">
            <button class="column-button manual-move" data-player="2" data-column="A">A</button>
            <button class="column-button manual-move" data-player="2" data-column="B">B</button>
            <button class="column-button manual-move" data-player="2" data-column="C">C</button>
            <button class="column-button manual-move" data-player="2" data-column="D">D</button>
            <button class="column-button manual-move" data-player="2" data-column="E">E</button>
            <button class="column-button manual-move" data-player="2" data-column="F">F</button>
            <button class="column-button manual-move" data-player="2" data-column="G">G</button>
          </div>
        </div>

        <div class="card" style="text-align: center;">
          <button id="end-manual-game" class="btn-danger">‚èπÔ∏è Test-Spiel beenden</button>
        </div>
      </div>

      <div class="card">
        <h3>‚ÑπÔ∏è Hinweise</h3>
        <ul style="line-height: 1.8; color: #aaa;">
          <li><strong>Manueller Modus:</strong> Du steuerst beide Spieler und kannst jeden Zug testen</li>
          <li><strong>Bot-Modus:</strong> Der Bot macht zuf√§llige Z√ºge (einfach f√ºr schnelles Testen)</li>
          <li><strong>Overlay:</strong> Das Spiel wird im Overlay angezeigt - √∂ffne es in OBS oder einem Browser</li>
          <li><strong>Offline:</strong> Funktioniert ohne TikTok-Verbindung, keine Geschenke oder Chat erforderlich</li>
          <li><strong>XP:</strong> Im Manual Mode wird kein XP vergeben (nur Test-Spieler)</li>
        </ul>
      </div>
    </div>

    <!-- Connect4 Tab -->
    <div class="tab-content" id="tab-connect4">
      <div class="card">
        <h2>Connect4 Einstellungen</h2>
        
        <div class="form-group">
          <label>Spielfeld-Farbe:</label>
          <div class="color-picker">
            <input type="color" id="boardColor" value="#2C3E50">
            <div class="color-preview" id="boardColorPreview"></div>
          </div>
        </div>

        <div class="form-group">
          <label>Spieler 1 Farbe (Zuschauer):</label>
          <div class="color-picker">
            <input type="color" id="player1Color" value="#E74C3C">
            <div class="color-preview" id="player1ColorPreview"></div>
          </div>
        </div>

        <div class="form-group">
          <label>Spieler 2 Farbe (Streamer):</label>
          <div class="color-picker">
            <input type="color" id="player2Color" value="#F1C40F">
            <div class="color-preview" id="player2ColorPreview"></div>
          </div>
        </div>

        <div class="form-group">
          <label>Text-Farbe:</label>
          <div class="color-picker">
            <input type="color" id="textColor" value="#FFFFFF">
            <div class="color-preview" id="textColorPreview"></div>
          </div>
        </div>

        <div class="form-group">
          <label>Schriftart:</label>
          <input type="text" id="fontFamily" value="Arial, sans-serif">
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="showCoordinates" checked>
            Koordinaten anzeigen (A-G)
          </label>
        </div>

        <div class="form-group">
          <label>Animations-Geschwindigkeit (ms):</label>
          <input type="number" id="animationSpeed" value="500" min="100" max="2000" step="100">
        </div>

        <div class="form-group">
          <label>Streamer Rolle:</label>
          <select id="streamerRole">
            <option value="player1">Spieler 1 (Rot)</option>
            <option value="player2" selected>Spieler 2 (Gelb)</option>
          </select>
        </div>

        <h3>Chat Command Einstellungen</h3>
        
        <div class="form-group">
          <label>Chat-Befehl zum Starten:</label>
          <input type="text" id="c4ChatCommand" value="c4start" placeholder="c4start" pattern="^[a-zA-Z0-9_-]+$" title="Nur Buchstaben, Zahlen, Unterstrich und Bindestrich erlaubt">
          <small>Definiere den Chat-Befehl zum Starten eines Connect4-Spiels (ohne / Pr√§fix). Nur alphanumerische Zeichen, Unterstrich und Bindestrich erlaubt.</small>
        </div>

        <h3>Challenge Flow Einstellungen</h3>
        
        <div class="form-group">
          <label>
            <input type="checkbox" id="showChallengeScreen" checked>
            Challenge-Bildschirm anzeigen
          </label>
        </div>

        <div class="form-group">
          <label>Challenge-Timeout (Sekunden):</label>
          <input type="number" id="challengeTimeout" value="30" min="5" max="120" step="5">
          <small>Zeit bis der Herausforderer gegen den Streamer spielt</small>
        </div>

        <h3>Leaderboard Einstellungen</h3>
        
        <div class="form-group">
          <label>
            <input type="checkbox" id="leaderboardEnabled" checked>
            Leaderboard nach Spiel anzeigen
          </label>
        </div>

        <div class="form-group">
          <label>Anzeigezeit pro Leaderboard (Sekunden):</label>
          <input type="number" id="leaderboardDisplayTime" value="3" min="1" max="10" step="1">
        </div>

        <div class="form-group">
          <label>Anzuzeigende Leaderboards:</label>
          <div>
            <label><input type="checkbox" id="leaderboardDaily" checked> T√§glich</label>
            <label><input type="checkbox" id="leaderboardSeason" checked> Saison</label>
            <label><input type="checkbox" id="leaderboardLifetime" checked> Allzeit</label>
            <label><input type="checkbox" id="leaderboardELORotation" checked> ELO</label>
          </div>
        </div>

        <h3>Round Timer Einstellungen</h3>
        
        <div class="form-group">
          <label>
            <input type="checkbox" id="roundTimerEnabled">
            Runden-Timer aktivieren
          </label>
        </div>

        <div class="form-group">
          <label>Zeit-Limit pro Zug (Sekunden):</label>
          <input type="number" id="roundTimeLimit" value="30" min="5" max="120" step="5">
        </div>

        <div class="form-group">
          <label>Warnzeit (Sekunden vor Ablauf):</label>
          <input type="number" id="roundWarningTime" value="10" min="3" max="30" step="1">
        </div>

        <button id="saveSettingsBtn">Einstellungen speichern</button>
      </div>
    </div>

    <!-- Chess (Blitzschach) Tab -->
    <div class="tab-content" id="tab-chess">
      <div class="card">
        <h2>‚ôüÔ∏è Blitzschach Einstellungen</h2>
        <p>Konfiguriere Schachspiele f√ºr TikTok LIVE Streams</p>

        <h3>‚öôÔ∏è Spiel-Einstellungen</h3>
        
        <div class="form-group">
          <label>Standard Zeitkontrolle:</label>
          <select id="chess-time-control">
            <option value="3+0">3 + 0 (Bullet)</option>
            <option value="3+2">3 + 2 (Bullet mit Inkrement)</option>
            <option value="5+0" selected>5 + 0 (Blitz)</option>
            <option value="5+3">5 + 3 (Blitz mit Inkrement)</option>
            <option value="10+0">10 + 0 (Rapid)</option>
            <option value="10+5">10 + 5 (Rapid mit Inkrement)</option>
          </select>
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Format: Minuten + Inkrement-Sekunden pro Zug
          </p>
        </div>

        <div class="form-group">
          <label>Streamer spielt als:</label>
          <select id="chess-streamer-role">
            <option value="random" selected>Zuf√§llig (Wei√ü oder Schwarz)</option>
            <option value="white">Immer Wei√ü</option>
            <option value="black">Immer Schwarz</option>
          </select>
        </div>

        <div class="form-group">
          <label>Timer-Warnung ab (Sekunden):</label>
          <input type="number" id="chess-timer-warning" value="30" min="5" max="60">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Timer wird orange wenn Zeit unter diesem Wert liegt
          </p>
        </div>

        <h3 style="margin-top: 30px;">üé® Darstellung</h3>

        <div class="form-group">
          <label>Brett-Theme:</label>
          <select id="chess-board-theme">
            <option value="dark" selected>Dunkel</option>
            <option value="light">Hell</option>
            <option value="wood">Holz</option>
          </select>
        </div>

        <div class="form-group">
          <label>Hintergrundfarbe:</label>
          <input type="color" id="chess-bg-color" value="#1a1a2e">
        </div>

        <div class="form-group">
          <label>Wei√ü Farbe (Akzent):</label>
          <input type="color" id="chess-white-color" value="#4CAF50">
        </div>

        <div class="form-group">
          <label>Schwarz Farbe (Akzent):</label>
          <input type="color" id="chess-black-color" value="#2196F3">
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-show-coordinates" checked> 
            Koordinaten anzeigen (A-H, 1-8)
          </label>
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-highlight-last-move" checked> 
            Letzten Zug hervorheben
          </label>
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-highlight-check" checked> 
            Schach hervorheben
          </label>
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-show-captured" checked> 
            Geschlagene Figuren anzeigen
          </label>
        </div>

        <div class="form-group">
          <label>Animationsgeschwindigkeit (ms):</label>
          <input type="number" id="chess-animation-speed" value="300" min="100" max="1000" step="50">
        </div>

        <h3 style="margin-top: 30px;">üéµ Sound & Effekte</h3>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-sound-enabled" checked> 
            Sound-Effekte aktivieren
          </label>
        </div>

        <div class="form-group">
          <label>Sound-Lautst√§rke:</label>
          <input type="range" id="chess-sound-volume" min="0" max="1" step="0.1" value="0.5">
          <span id="chess-volume-display">50%</span>
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-celebration-enabled" checked> 
            Konfetti-Effekt bei Sieg
          </label>
        </div>

        <h3 style="margin-top: 30px;">üèÜ Leaderboard & Challenge</h3>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-challenge-screen" checked> 
            Challenge-Bildschirm anzeigen
          </label>
        </div>

        <div class="form-group">
          <label>Challenge-Timeout (Sekunden):</label>
          <input type="number" id="chess-challenge-timeout" value="30" min="5" max="120">
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-leaderboard-enabled" checked> 
            Leaderboard nach Spiel anzeigen
          </label>
        </div>

        <div class="form-group">
          <label>Anzeigezeit pro Leaderboard (Sekunden):</label>
          <input type="number" id="chess-leaderboard-display-time" value="3" min="1" max="10">
        </div>

        <h3 style="margin-top: 30px;">üìä ELO System</h3>

        <div class="form-group">
          <label>
            <input type="checkbox" id="chess-elo-enabled" checked> 
            ELO-System aktivieren
          </label>
        </div>

        <div class="form-group">
          <label>Start-ELO:</label>
          <input type="number" id="chess-elo-start" value="1000" min="100" max="3000" step="100">
        </div>

        <div class="form-group">
          <label>K-Faktor:</label>
          <input type="number" id="chess-elo-k-factor" value="32" min="10" max="50">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            H√∂herer Wert = st√§rkere ELO-√Ñnderungen pro Spiel
          </p>
        </div>

        <button id="saveChessSettingsBtn">Schach-Einstellungen speichern</button>
      </div>

      <div class="card">
        <h2>üì∫ Chess Overlay URL</h2>
        <p>F√ºge diese URL als Browser-Quelle in OBS hinzu:</p>
        <div class="form-group">
          <label>Chess Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="chess-overlay-url" value="http://localhost:3000/overlay/game-engine/chess" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-chess-overlay">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-chess-overlay">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene OBS Einstellungen:</strong>
          <ul style="margin: 8px 0 0 20px; color: #aaa; font-size: 14px;">
            <li>Breite: 1920</li>
            <li>H√∂he: 1080</li>
            <li>Benutzerdefiniertes CSS: <code>body { background-color: rgba(0, 0, 0, 0); }</code></li>
          </ul>
        </div>
      </div>

      <div class="card">
        <h2>üéÆ Chat-Befehle</h2>
        <div style="background: #3a3a4e; padding: 15px; border-radius: 8px;">
          <h4 style="color: #4CAF50; margin-top: 0;">F√ºr Zuschauer:</h4>
          <ul style="margin: 10px 0 0 20px; color: #eee;">
            <li><code>/chessstart</code> oder <code>/chessstart 3+0</code> - Startet ein neues Schachspiel</li>
            <li><code>/move e4</code> oder <code>/m e4</code> - Macht einen Zug (SAN-Format)</li>
            <li><code>/move e2e4</code> oder <code>/m e2e4</code> - Macht einen Zug (UCI-Format)</li>
            <li><code>/resign</code> - Aufgeben</li>
          </ul>
          <h4 style="color: #4CAF50; margin-top: 15px;">Beispiele:</h4>
          <ul style="margin: 10px 0 0 20px; color: #888;">
            <li><code>/m e4</code> - Bauer von e2 nach e4</li>
            <li><code>/m Nf3</code> - Springer nach f3</li>
            <li><code>/m O-O</code> - Kurze Rochade</li>
            <li><code>/m Qxd5</code> - Dame schl√§gt auf d5</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Plinko Tab -->
    <div class="tab-content" id="tab-plinko">
      <div class="card">
        <h2>üé∞ Plinko Board Verwaltung</h2>
        <p>Verwalte mehrere Plinko-Boards mit individuellen Konfigurationen</p>
        
        <div class="form-group">
          <label>Aktives Plinko-Board:</label>
          <select id="plinko-board-selector" style="width: 100%; margin-bottom: 10px;">
            <!-- Boards will be loaded here -->
          </select>
        </div>
        
        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
          <button id="createPlinkoBoardBtn" class="secondary">‚ûï Neues Board erstellen</button>
          <button id="deletePlinkoBoardBtn" class="danger">üóëÔ∏è Board l√∂schen</button>
        </div>
        
        <div class="form-group">
          <label>Board-Name:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="plinko-board-name" placeholder="Board-Name eingeben...">
            <button id="updatePlinkoBoardNameBtn" class="secondary">üíæ Name speichern</button>
          </div>
        </div>
        
        <div class="form-group">
          <label>Chat-Befehl (optional):</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="plinko-board-chat-command" placeholder="z.B. /plinko">
            <button id="updatePlinkoBoardChatCommandBtn" class="secondary">üíæ Befehl speichern</button>
          </div>
          <small style="color: #888;">Zuschauer k√∂nnen diesen Befehl nutzen, um Drops auf diesem Board zu triggern.</small>
        </div>
        
        <div class="form-group">
          <label>
            <input type="checkbox" id="plinko-board-enabled">
            Board aktiviert
          </label>
        </div>
      </div>
      
      <div class="card">
        <h2>üé∞ Plinko Einstellungen</h2>
        <p>Konfiguriere das physikbasierte Plinko-Spiel f√ºr TikTok LIVE Streams</p>

        <h3>üéØ Slot-Konfiguration</h3>
        <p style="color: #888; font-size: 14px; margin-bottom: 10px;">
          Definiere die Multiplikatoren und Farben f√ºr jeden Slot am Boden des Spielfelds.
        </p>
        
        <div id="plinko-slots-container" style="margin-bottom: 20px;">
          <!-- Slots will be dynamically loaded here -->
        </div>

        <button id="addPlinkoSlotBtn" class="secondary">‚ûï Slot hinzuf√ºgen</button>
        <button id="removePlinkoSlotBtn" class="danger">‚ûñ Letzten Slot entfernen</button>

        <h3 style="margin-top: 30px;">‚öôÔ∏è Physik-Einstellungen</h3>

        <div class="form-group">
          <label>
            <input type="checkbox" id="plinko-test-mode">
            üß™ Test Mode aktivieren (Offline Simulation ohne XP)
          </label>
          <small style="color: #888;">Erm√∂glicht lokale Drops ohne TikTok/Xp, ideal f√ºr Debugging.</small>
        </div>

        <div class="form-group">
          <label>Maximale B√§lle pro Drop:</label>
          <input type="number" id="plinko-max-balls" value="5" min="1" max="20" step="1">
        </div>

        <div class="form-group">
          <label>Schwerkraft:</label>
          <input type="number" id="plinko-gravity" value="1.0" min="0.1" max="3.0" step="0.1">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            H√∂here Werte = schnelleres Fallen (Standard: 1.0)
          </p>
        </div>

        <div class="form-group">
          <label>Ball-Elastizit√§t (Restitution):</label>
          <input type="number" id="plinko-ball-restitution" value="0.6" min="0.1" max="1.0" step="0.1">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Wie stark der Ball abprallt (0.1 = schwach, 1.0 = sehr elastisch)
          </p>
        </div>

        <div class="form-group">
          <label>Peg-Elastizit√§t:</label>
          <input type="number" id="plinko-peg-restitution" value="0.8" min="0.1" max="1.0" step="0.1">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Wie elastisch die Pegs sind
          </p>
        </div>

        <div class="form-group">
          <label>Anzahl Peg-Reihen:</label>
          <input type="number" id="plinko-peg-rows" value="12" min="8" max="16" step="1">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Mehr Reihen = l√§ngere Fallzeit und unvorhersehbareres Ergebnis
          </p>
        </div>

        <div class="form-group">
          <label>Peg-Abstand (Pixel):</label>
          <input type="number" id="plinko-peg-spacing" value="60" min="40" max="100" step="5">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Abstand zwischen den Pegs
          </p>
        </div>

        <button id="savePlinkoSettingsBtn">üé∞ Plinko-Einstellungen speichern</button>
      </div>

      <div class="card">
        <h2>üéÅ Geschenk-zu-Ball Mapping</h2>
        <p>Verkn√ºpfe TikTok-Geschenke mit speziellen Plinko-B√§llen</p>
        <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
          Wenn ein Zuschauer das konfigurierte Geschenk sendet, wird automatisch ein Plinko-Ball mit den gew√§hlten Einstellungen gespawnt.
        </p>

        <div id="plinko-gift-mappings-container" style="margin-bottom: 20px;">
          <!-- Gift mappings will be dynamically loaded here -->
        </div>

        <div class="form-group" style="display: flex; gap: 10px; align-items: flex-end;">
          <div style="flex: 1;">
            <label>Geschenk-Name oder ID:</label>
            <input type="text" id="plinko-new-gift-mapping" placeholder="z.B. Rose oder 5655">
          </div>
          <button id="addPlinkoGiftMappingBtn" class="secondary">‚ûï Geschenk hinzuf√ºgen</button>
        </div>
        
        <button id="openPlinkoGiftCatalogBtn" style="margin-top: 10px;">üì¶ Geschenk-Katalog √∂ffnen</button>
      </div>

      <div class="card">
        <h2>üìä Plinko Statistiken</h2>
        <div id="plinko-stats-container">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" id="plinko-total-games">0</div>
              <div class="stat-label">Gespielte Runden</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="plinko-total-bet">0</div>
              <div class="stat-label">Total XP Eingesetzt</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="plinko-total-payout">0</div>
              <div class="stat-label">Total XP Ausgezahlt</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="plinko-rtp">0%</div>
              <div class="stat-label">RTP (Return to Player)</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="plinko-avg-multiplier">0x</div>
              <div class="stat-label">Durchschn. Multiplikator</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="plinko-max-win">0</div>
              <div class="stat-label">H√∂chster Gewinn (Net)</div>
            </div>
          </div>
        </div>
        <button id="refreshPlinkoStatsBtn" class="secondary" style="margin-top: 15px;">üîÑ Statistiken aktualisieren</button>
      </div>

      <div class="card">
        <h2>üì∫ Plinko Overlay URL</h2>
        <p>F√ºge diese URL als Browser-Quelle in OBS hinzu:</p>
        <div class="form-group">
          <label>Plinko Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="plinko-overlay-url" value="http://localhost:3000/overlay/game-engine/plinko" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-plinko-overlay">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-plinko-overlay">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene OBS Einstellungen:</strong>
          <ul style="margin: 8px 0 0 20px; color: #aaa; font-size: 14px;">
            <li>Breite: 1920</li>
            <li>H√∂he: 1080</li>
            <li>Benutzerdefiniertes CSS: <code>body { background-color: rgba(0, 0, 0, 0); }</code></li>
          </ul>
        </div>
      </div>

      <div class="card">
        <h2>üéÆ Chat-Befehle</h2>
        <div style="background: #3a3a4e; padding: 15px; border-radius: 8px;">
          <h4 style="color: #4CAF50; margin-top: 0;">F√ºr Zuschauer:</h4>
          <ul style="margin: 8px 0 0 20px; color: #aaa; font-size: 14px; line-height: 1.8;">
            <li><code>!plinko &lt;betrag&gt;</code> - Setze XP und lass einen Ball fallen (z.B. !plinko 100)</li>
            <li><code>!plinko max</code> - Setze alle deine XP auf einmal</li>
          </ul>
          <h4 style="color: #64B5F6; margin-top: 15px;">Geschenk-Trigger:</h4>
          <p style="color: #aaa; font-size: 14px; margin: 8px 0 0 20px;">
            Konfiguriere Geschenke im Tab "Trigger" oben, um automatisch Plinko-B√§lle zu spawnen, wenn Zuschauer bestimmte Geschenke senden.
          </p>
        </div>
      </div>
    </div>

    <!-- Plinko Test Tab -->
    <div class="tab-content" id="tab-plinko-test">
      <div class="card">
        <h2>üß™ Plinko Offline-Testmodus</h2>
        <p>Spawne Test-B√§lle ohne TikTok-Verbindung oder XP-System</p>
        
        <div class="form-group">
          <label>Test-Board:</label>
          <select id="test-board-selector" style="width: 100%;">
            <!-- Boards will be loaded dynamically -->
          </select>
        </div>
        
        <div class="form-group">
          <label>Spieler-Name:</label>
          <input type="text" id="test-player-name" value="TestUser" placeholder="Name des Test-Spielers" style="width: 100%;">
        </div>
        
        <div class="form-group">
          <label>Einsatz (XP):</label>
          <input type="number" id="test-bet-amount" value="100" min="10" max="10000" step="10" style="width: 100%; margin-bottom: 10px;">
          <input type="range" id="test-bet-slider" min="10" max="1000" value="100" step="10" style="width: 100%;">
          <small style="color: #888;">Bereich: 10 - 10.000 XP (Slider max: 1000)</small>
        </div>
        
        <div class="form-group">
          <label>Anzahl B√§lle:</label>
          <input type="number" id="test-ball-count" value="1" min="1" max="10" step="1" style="width: 100%;">
        </div>
        
        <div style="display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap;">
          <button id="test-spawn-single-btn" class="secondary">üé∞ Ball spawnen</button>
          <button id="test-spawn-batch-btn" class="secondary">üé∞üé∞ Batch spawnen (mehrere User)</button>
          <button id="test-clear-history-btn" class="danger">üóëÔ∏è Test-History l√∂schen</button>
        </div>
      </div>

      <div class="card">
        <h3>‚ö° Schnell-Presets</h3>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button class="test-preset secondary" data-bet="50" data-count="1">50 XP Single</button>
          <button class="test-preset secondary" data-bet="100" data-count="3">100 XP x3</button>
          <button class="test-preset secondary" data-bet="500" data-count="5">500 XP x5</button>
          <button class="test-preset secondary" data-bet="1000" data-count="10">1000 XP x10</button>
        </div>
      </div>

      <div class="card">
        <h3>üìä Test-Session Statistiken</h3>
        <div class="stats-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
          <div class="stat-card" style="background: rgba(100, 181, 246, 0.1); padding: 20px; border-radius: 8px; text-align: center;">
            <div class="stat-value" id="test-total-spawns" style="font-size: 32px; font-weight: bold; color: #64B5F6;">0</div>
            <div class="stat-label" style="color: #aaa; margin-top: 5px;">Balls spawned</div>
          </div>
          <div class="stat-card" style="background: rgba(100, 181, 246, 0.1); padding: 20px; border-radius: 8px; text-align: center;">
            <div class="stat-value" id="test-total-bet" style="font-size: 32px; font-weight: bold; color: #64B5F6;">0 XP</div>
            <div class="stat-label" style="color: #aaa; margin-top: 5px;">Total bet</div>
          </div>
          <div class="stat-card" style="background: rgba(100, 181, 246, 0.1); padding: 20px; border-radius: 8px; text-align: center;">
            <div class="stat-value" id="test-avg-multiplier" style="font-size: 32px; font-weight: bold; color: #64B5F6;">0.00x</div>
            <div class="stat-label" style="color: #aaa; margin-top: 5px;">Avg Multiplier</div>
          </div>
          <div class="stat-card" style="background: rgba(100, 181, 246, 0.1); padding: 20px; border-radius: 8px; text-align: center;">
            <div class="stat-value" id="test-rtp" style="font-size: 32px; font-weight: bold; color: #64B5F6;">0%</div>
            <div class="stat-label" style="color: #aaa; margin-top: 5px;">RTP</div>
          </div>
        </div>
        <button id="test-refresh-stats-btn" class="secondary">üîÑ Stats aktualisieren</button>
      </div>

      <div class="card">
        <h3>üìú Letzte Test-Drops</h3>
        <div id="test-history-container" style="max-height: 400px; overflow-y: auto;">
          <table style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr style="background: rgba(100, 181, 246, 0.1); border-bottom: 2px solid rgba(100, 181, 246, 0.3);">
                <th style="padding: 10px; text-align: left;">Zeit</th>
                <th style="padding: 10px; text-align: left;">Spieler</th>
                <th style="padding: 10px; text-align: right;">Bet</th>
                <th style="padding: 10px; text-align: right;">Multiplier</th>
                <th style="padding: 10px; text-align: right;">Gewinn/Verlust</th>
              </tr>
            </thead>
            <tbody id="test-history-tbody">
              <!-- Rows will be dynamically added here -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Gl√ºcksrad (Wheel of Fortune) Tab -->
    <div class="tab-content" id="tab-wheel">
      <!-- Wheel Selector Card -->
      <div class="card">
        <h2>üé° Gl√ºcksrad-Verwaltung</h2>
        <p>Verwalte mehrere Gl√ºcksr√§der mit individuellen Konfigurationen und Triggern</p>
        
        <div style="display: flex; gap: 15px; align-items: flex-end; margin-top: 15px; flex-wrap: wrap;">
          <div style="flex: 1; min-width: 200px;">
            <label>Aktives Gl√ºcksrad:</label>
            <select id="wheel-selector" style="width: 100%; padding: 10px; font-size: 16px;">
              <!-- Wheels will be loaded here -->
            </select>
          </div>
          <button id="createNewWheelBtn" class="secondary" style="white-space: nowrap;">‚ûï Neues Wheel erstellen</button>
          <button id="deleteCurrentWheelBtn" class="danger" style="white-space: nowrap;">üóëÔ∏è Wheel l√∂schen</button>
        </div>
        
        <div style="background: #2a4a3e; padding: 12px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #4CAF50;">
          <strong style="color: #4CAF50;">üí° Multi-Wheel System:</strong>
          <span style="color: #aaa; font-size: 14px;">
            Erstelle separate Wheels f√ºr verschiedene Geschenke oder Chat-Commands. Alle Wheels nutzen dasselbe Overlay und die Queue.
          </span>
        </div>
      </div>
      
      <!-- Current Wheel Configuration -->
      <div class="card">
        <h2>‚öôÔ∏è Wheel Konfiguration: <span id="current-wheel-name" style="color: #4CAF50;">Standard Wheel</span></h2>
        
        <div class="form-group">
          <label>Wheel-Name:</label>
          <input type="text" id="wheel-name-input" value="Standard Wheel" placeholder="Name des Wheels">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Ein beschreibender Name f√ºr dieses Wheel (z.B. "Rose Wheel", "VIP Wheel")
          </p>
        </div>
        
        <div class="form-group">
          <label>
            <input type="checkbox" id="wheel-enabled" checked>
            Wheel aktiviert
          </label>
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Deaktivierte Wheels reagieren nicht auf Trigger
          </p>
        </div>

        <h3 style="margin-top: 25px;">üéØ Trigger-Konfiguration</h3>
        <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
          Konfiguriere wie dieses Wheel ausgel√∂st wird (via Geschenk oder Chat-Command).
        </p>
        
        <div class="form-group">
          <label>Chat-Command (optional):</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <span style="color: #888;">/</span>
            <input type="text" id="wheel-chat-command" placeholder="z.B. spin oder wheel" style="flex: 1;">
          </div>
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Zuschauer k√∂nnen dieses Wheel mit dem Command im Chat ausl√∂sen (z.B. /spin)
          </p>
        </div>
        
        <h4 style="margin-top: 20px;">üéÅ Geschenk-Trigger</h4>
        <p style="color: #888; font-size: 14px; margin-bottom: 10px;">
          Wenn ein Zuschauer eines dieser Geschenke sendet, wird dieses Wheel gedreht.
        </p>

        <div id="wheel-gift-triggers-container" style="margin-bottom: 20px;">
          <!-- Gift triggers will be dynamically loaded here -->
        </div>

        <div class="form-group" style="display: flex; gap: 10px; align-items: flex-end;">
          <div style="flex: 1;">
            <label>Geschenk-Name oder ID:</label>
            <input type="text" id="wheel-new-gift-trigger" placeholder="z.B. Rose oder 5655">
          </div>
          <button id="addWheelGiftTriggerBtn" class="secondary">‚ûï Geschenk hinzuf√ºgen</button>
        </div>
        
        <button id="openWheelGiftCatalogBtn" style="margin-top: 10px;">üì¶ Geschenk-Katalog √∂ffnen</button>

        <h3 style="margin-top: 30px;">üéØ Segment-Konfiguration</h3>
        <p style="color: #888; font-size: 14px; margin-bottom: 10px;">
          Definiere die Segmente des Gl√ºcksrads mit Text, Farben und Gewichtung (h√∂here Gewichtung = h√§ufiger gewonnen).
          <br><strong>Tipp:</strong> Ziehe Segmente per Drag & Drop zum Verschieben, nutze üìã zum Kopieren und üóëÔ∏è zum L√∂schen.
        </p>
        
        <div style="background: #2a4a3e; padding: 12px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
          <strong style="color: #4CAF50;">‚≠ê XP Belohnungen:</strong>
          <span style="color: #aaa; font-size: 14px;">
            Trage einen XP-Wert ein, um automatisch XP zu vergeben wenn das Segment gewonnen wird. Lasse das Feld leer oder auf 0 f√ºr keine XP-Belohnung.
          </span>
        </div>
        
        <div id="wheel-segments-container" style="margin-bottom: 20px;">
          <!-- Segments will be dynamically loaded here -->
        </div>

        <button id="addWheelSegmentBtn" class="secondary">‚ûï Neues Segment hinzuf√ºgen</button>

        <h3 style="margin-top: 30px;">‚öôÔ∏è Allgemeine Einstellungen</h3>

        <div class="form-group">
          <label>Spin-Dauer (Millisekunden):</label>
          <input type="number" id="wheel-spin-duration" value="5000" min="2000" max="10000" step="500">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Wie lange das Rad dreht (Standard: 5000ms = 5 Sekunden)
          </p>
        </div>

        <div class="form-group">
          <label>Gewinner-Anzeige Dauer (Sekunden):</label>
          <input type="number" id="wheel-winner-display-duration" value="5" min="2" max="30" step="1">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Wie lange der Gewinner eingeblendet wird (Standard: 5 Sekunden)
          </p>
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="wheel-sound-enabled" checked>
            Sound-Effekte aktivieren
          </label>
        </div>

        <div class="form-group">
          <label>Sound-Lautst√§rke:</label>
          <input type="range" id="wheel-sound-volume" min="0" max="1" step="0.1" value="0.7">
          <span id="wheel-volume-display">70%</span>
        </div>

        <h3 style="margin-top: 30px;">üîä Custom Audio-Dateien</h3>
        <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
          Lade eigene Audio-Dateien hoch f√ºr das Wheel. Die Spin-Dauer wird automatisch an die L√§nge der Spinning-Audio angepasst.
        </p>

        <div class="form-group">
          <label>üé∞ Spinning Sound (spielt w√§hrend das Rad dreht):</label>
          <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
            <input type="file" id="wheel-audio-spinning" accept="audio/*" style="flex: 1;">
            <button type="button" id="wheel-audio-spinning-preview" class="secondary" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            <button type="button" id="wheel-audio-spinning-reset" class="danger" style="padding: 8px 15px;" title="Zur√ºcksetzen">üîÑ</button>
          </div>
          <p id="wheel-audio-spinning-status" style="color: #4CAF50; font-size: 12px; margin-top: 5px;">Standard: spinning sound.mp3</p>
        </div>

        <div class="form-group">
          <label>üèÜ Preis 1 Audio (f√ºr Segmente mit Audio=1):</label>
          <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
            <input type="file" id="wheel-audio-prize1" accept="audio/*" style="flex: 1;">
            <button type="button" id="wheel-audio-prize1-preview" class="secondary" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            <button type="button" id="wheel-audio-prize1-reset" class="danger" style="padding: 8px 15px;" title="Zur√ºcksetzen">üîÑ</button>
          </div>
          <p id="wheel-audio-prize1-status" style="color: #4CAF50; font-size: 12px; margin-top: 5px;">Standard: price 1 audio.mp3</p>
        </div>

        <div class="form-group">
          <label>üèÜ Preis 2 Audio (f√ºr Segmente mit Audio=2):</label>
          <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
            <input type="file" id="wheel-audio-prize2" accept="audio/*" style="flex: 1;">
            <button type="button" id="wheel-audio-prize2-preview" class="secondary" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            <button type="button" id="wheel-audio-prize2-reset" class="danger" style="padding: 8px 15px;" title="Zur√ºcksetzen">üîÑ</button>
          </div>
          <p id="wheel-audio-prize2-status" style="color: #4CAF50; font-size: 12px; margin-top: 5px;">Standard: price 2 audio.mp3</p>
        </div>

        <div class="form-group">
          <label>üèÜ Preis 3 Audio (f√ºr Segmente mit Audio=3):</label>
          <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
            <input type="file" id="wheel-audio-prize3" accept="audio/*" style="flex: 1;">
            <button type="button" id="wheel-audio-prize3-preview" class="secondary" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            <button type="button" id="wheel-audio-prize3-reset" class="danger" style="padding: 8px 15px;" title="Zur√ºcksetzen">üîÑ</button>
          </div>
          <p id="wheel-audio-prize3-status" style="color: #4CAF50; font-size: 12px; margin-top: 5px;">Standard: price 3 audio.mp3</p>
        </div>

        <div class="form-group">
          <label>üò¢ Niete/Lost Audio (spielt bei keinem Gewinn):</label>
          <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
            <input type="file" id="wheel-audio-lost" accept="audio/*" style="flex: 1;">
            <button type="button" id="wheel-audio-lost-preview" class="secondary" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            <button type="button" id="wheel-audio-lost-reset" class="danger" style="padding: 8px 15px;" title="Zur√ºcksetzen">üîÑ</button>
          </div>
          <p id="wheel-audio-lost-status" style="color: #4CAF50; font-size: 12px; margin-top: 5px;">Standard: lost.mp3</p>
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="wheel-show-queue" checked>
            Warteschlange im Overlay anzeigen
          </label>
        </div>

        <h3 style="margin-top: 30px;">üò¢ Niete (Kein Gewinn) Einstellungen</h3>
        <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
          Markiere Segmente als "Niete", um einen anderen Text anzuzeigen, wenn der Spieler keinen Gewinn bekommt.
        </p>

        <div class="form-group">
          <label>Niete-Text (wird angezeigt statt Gewinn):</label>
          <input type="text" id="wheel-niete-text" value="Leider kein Gewinn!" placeholder="z.B. Leider kein Gewinn!">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Dieser Text wird angezeigt, wenn ein Segment als "Niete" markiert ist.
          </p>
        </div>

        <h3 style="margin-top: 30px;">üí¨ Idle-Nachricht Einstellungen</h3>
        <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
          Passe die Nachricht an, die im OBS Overlay angezeigt wird, wenn das Gl√ºcksrad auf Spieler wartet.
        </p>

        <div class="form-group">
          <label>
            <input type="checkbox" id="wheel-idle-message-enabled">
            Idle-Nachricht anzeigen
          </label>
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Zeigt eine Nachricht im Overlay an, wenn kein Spiel aktiv ist.
          </p>
        </div>

        <div class="form-group">
          <label>Idle-Nachricht Titel:</label>
          <input type="text" id="wheel-idle-message-title" value="üé° Warte auf Spieler..." placeholder="z.B. üé° Warte auf Spieler...">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Der Haupttitel der Idle-Nachricht (erste Zeile)
          </p>
        </div>

        <div class="form-group">
          <label>Idle-Nachricht Untertitel:</label>
          <input type="text" id="wheel-idle-message-subtitle" value="Sende ein Geschenk, um das Gl√ºcksrad zu drehen!" placeholder="z.B. Sende ein Geschenk, um das Gl√ºcksrad zu drehen!">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Der Untertitel der Idle-Nachricht (zweite Zeile)
          </p>
        </div>

        <h3 style="margin-top: 30px;">‚ÑπÔ∏è Info-Screen Einstellungen</h3>
        <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
          Zeige einen Info-Screen nach einem Gewinn, um dem Spieler zu sagen, wie er seinen Preis abholen kann.
        </p>

        <div class="form-group">
          <label>
            <input type="checkbox" id="wheel-info-screen-enabled">
            Info-Screen nach Gewinn anzeigen
          </label>
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Der Info-Screen wird nur bei echten Gewinnen angezeigt, nicht bei "Niete".
          </p>
        </div>

        <div class="form-group">
          <label>Info-Screen Text:</label>
          <textarea id="wheel-info-screen-text" rows="3" style="width: 100%; padding: 10px; background: #1a1a2e; border: 1px solid #444; border-radius: 5px; color: #eee; font-size: 14px; resize: vertical;">Um deinen Gewinn abzuholen, besuche discord.gg/deinserver</textarea>
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            z.B. "Um deinen Gewinn abzuholen, besuche discord.gg/pawsunited"
          </p>
        </div>

        <div class="form-group">
          <label>Info-Screen Anzeigedauer (Sekunden):</label>
          <input type="number" id="wheel-info-screen-duration" value="5" min="2" max="30" step="1">
          <p style="color: #888; font-size: 12px; margin-top: 5px;">
            Wie lange der Info-Screen angezeigt wird (Standard: 5 Sekunden)
          </p>
        </div>

        <button id="saveWheelSettingsBtn">üé° Wheel-Einstellungen speichern</button>
      </div>

      <div class="card">
        <h2>üìä Gl√ºcksrad Statistiken</h2>
        <div id="wheel-stats-container">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" id="wheel-total-spins">0</div>
              <div class="stat-label">Gesamte Spins</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="wheel-unique-players">0</div>
              <div class="stat-label">Einzigartige Spieler</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="wheel-prizes-paid">0</div>
              <div class="stat-label">Preise ausgezahlt</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="wheel-prizes-pending">0</div>
              <div class="stat-label">Preise ausstehend</div>
            </div>
          </div>
          
          <h3 style="margin-top: 20px;">üèÜ Beliebteste Preise</h3>
          <div id="wheel-popular-prizes" style="margin-top: 10px; color: #aaa;">
            Lade...
          </div>
        </div>
        <button id="refreshWheelStatsBtn" class="secondary" style="margin-top: 15px;">üîÑ Statistiken aktualisieren</button>
      </div>

      <div class="card">
        <h2>üìã Gewinnerliste verwalten</h2>
        <p>√úbersicht aller Gewinne mit Bearbeitung, Auszahlungsstatus und Reset-Optionen</p>
        
        <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
          <button id="showUnpaidWinsBtn" class="secondary">üìã Nur Ausstehende</button>
          <button id="showAllWinsBtn" class="secondary">üìú Alle Gewinne</button>
          <button id="resetAllWinsBtn" class="danger" style="margin-left: auto;">üóëÔ∏è Alle Gewinne l√∂schen</button>
        </div>
        
        <div id="wheel-wins-log" style="max-height: 400px; overflow-y: auto;">
          <table style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr style="background: #3a3a4e;">
                <th style="padding: 10px; text-align: left;">Datum</th>
                <th style="text-align: left;">Spieler</th>
                <th style="text-align: left;">Gewinn</th>
                <th style="text-align: left;">Geschenk</th>
                <th style="text-align: center;">Status</th>
                <th style="text-align: center;">Aktionen</th>
              </tr>
            </thead>
            <tbody id="wheel-wins-table-body">
              <!-- Wins will be loaded here -->
            </tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <h2>üéÆ Test-Spin</h2>
        <p>Teste das Gl√ºcksrad ohne Geschenk</p>
        
        <div class="form-group">
          <label>Test-Spielername:</label>
          <input type="text" id="wheel-test-player" value="TestSpieler" placeholder="Name des Testspielers">
        </div>
        
        <button id="triggerTestSpinBtn">üé° Test-Spin starten</button>
      </div>

      <div class="card">
        <h2>üì∫ Gl√ºcksrad Overlay URL</h2>
        <p>F√ºge diese URL als Browser-Quelle in OBS hinzu:</p>
        <div class="form-group">
          <label>Wheel Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="wheel-overlay-url" value="http://localhost:3000/overlay/game-engine/wheel" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-wheel-overlay">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-wheel-overlay">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene OBS Einstellungen:</strong>
          <ul style="margin: 8px 0 0 20px; color: #aaa; font-size: 14px;">
            <li>Breite: 1920</li>
            <li>H√∂he: 1080</li>
            <li>Benutzerdefiniertes CSS: <code>body { background-color: rgba(0, 0, 0, 0); }</code></li>
          </ul>
        </div>
      </div>
    </div>

    <!-- OBS Overlays Tab - ALL GAME OVERLAYS COLLECTED HERE -->
    <div class="tab-content" id="tab-overlays">
      <div class="card">
        <h2>üì∫ Alle OBS Overlay URLs</h2>
        <p>F√ºge diese URLs als Browser-Quellen in OBS Studio hinzu, um die Overlays in deinem Stream anzuzeigen.</p>
        <p style="color: #888; font-size: 14px; margin-top: 5px;">
          <strong>Hinweis:</strong> Alle Overlays unterst√ºtzen transparenten Hintergrund. Verwende in OBS: <code>body { background-color: rgba(0, 0, 0, 0); }</code>
        </p>
      </div>

      <!-- Connect4 Overlay -->
      <div class="card">
        <h3>üéÆ Connect4 Overlay</h3>
        <p style="color: #aaa; font-size: 14px; margin-bottom: 10px;">
          Zeigt das komplette Connect4 Spielfeld mit Animationen, Challenge-Screen und Leaderboards.
        </p>
        <div class="form-group">
          <label>Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="overlay-url-gameboard" value="http://localhost:3000/overlay/game-engine/connect4" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-gameboard">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-gameboard">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene Gr√∂√üe:</strong> 1920 x 1080
        </div>
      </div>

      <!-- Chess Overlay -->
      <div class="card">
        <h3>‚ôüÔ∏è Blitzschach Overlay</h3>
        <p style="color: #aaa; font-size: 14px; margin-bottom: 10px;">
          Zeigt das Schachbrett mit Timer, geschlagenen Figuren und Spielerinfo.
        </p>
        <div class="form-group">
          <label>Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="overlay-url-chess" value="http://localhost:3000/overlay/game-engine/chess" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-chess-overlay-main">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-chess-overlay-main">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene Gr√∂√üe:</strong> 1920 x 1080
        </div>
      </div>

      <!-- Plinko Overlay -->
      <div class="card">
        <h3>üé∞ Plinko Overlay</h3>
        <p style="color: #aaa; font-size: 14px; margin-bottom: 10px;">
          Physikbasiertes Plinko-Spiel mit Multiplikatoren und Ball-Animationen.
        </p>
        <div class="form-group">
          <label>Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="overlay-url-plinko" value="http://localhost:3000/overlay/game-engine/plinko" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-plinko-overlay-main">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-plinko-overlay-main">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene Gr√∂√üe:</strong> 1920 x 1080
        </div>
      </div>

      <!-- Wheel (Gl√ºcksrad) Overlay -->
      <div class="card">
        <h3>üé° Gl√ºcksrad Overlay</h3>
        <p style="color: #aaa; font-size: 14px; margin-bottom: 10px;">
          Zeigt das Gl√ºcksrad mit Spin-Animationen, Warteschlange und Gewinner-Anzeige.
        </p>
        <div class="form-group">
          <label>Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="overlay-url-wheel" value="http://localhost:3000/overlay/game-engine/wheel" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-wheel-overlay-main">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-wheel-overlay-main">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene Gr√∂√üe:</strong> 1920 x 1080
        </div>
      </div>

      <!-- Game HUD Overlay -->
      <div class="card">
        <h3>üìä Kompaktes HUD Overlay</h3>
        <p style="color: #aaa; font-size: 14px; margin-bottom: 10px;">
          Kleines Status-Overlay mit Spielinformationen, das permanent eingeblendet bleiben kann.
        </p>
        <div class="form-group">
          <label>Overlay URL:</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="text" id="overlay-url-hud" value="http://localhost:3000/overlay/game-engine/hud" readonly style="flex: 1;">
            <button class="secondary" id="btn-copy-hud">üìã Kopieren</button>
            <button class="secondary" id="btn-preview-hud">üëÅÔ∏è Vorschau</button>
          </div>
        </div>
        <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 10px;">
          <strong>Empfohlene Gr√∂√üe:</strong> 400 x 300
        </div>

        <h4 style="margin-top: 20px; color: #64B5F6;">‚öôÔ∏è HUD URL-Parameter</h4>
        <div style="background: #3a3a4e; padding: 15px; border-radius: 8px; margin-top: 10px;">
          <strong>Position:</strong>
          <ul style="margin: 8px 0 10px 20px; color: #aaa; font-size: 14px;">
            <li><code>?position=top-left</code> - Oben links (Standard)</li>
            <li><code>?position=top-right</code> - Oben rechts</li>
            <li><code>?position=bottom-left</code> - Unten links</li>
            <li><code>?position=bottom-right</code> - Unten rechts</li>
            <li><code>?position=center</code> - Oben mittig</li>
          </ul>
          <strong>Weitere Optionen:</strong>
          <ul style="margin: 8px 0 10px 20px; color: #aaa; font-size: 14px;">
            <li><code>&minimal=true</code> - Kompaktere Ansicht ohne Statistiken</li>
            <li><code>&hideWhenInactive=true</code> - HUD nur anzeigen wenn Spiel aktiv</li>
          </ul>
        </div>
      </div>

      <div class="card" style="background: #2a4a3e; border-left: 4px solid #4CAF50;">
        <strong style="color: #4CAF50;">üí° Tipp:</strong>
        <p style="margin: 5px 0 0 0; color: #aaa; font-size: 14px;">
          Du kannst mehrere Overlays gleichzeitig verwenden! F√ºge das jeweilige Spiel-Overlay f√ºr Spiele und das kompakte HUD f√ºr dauerhafte Anzeige hinzu.
        </p>
      </div>
    </div>

    <!-- Triggers Tab -->
    <div class="tab-content" id="tab-triggers">
      <div class="card">
        <h2>Spiel-Trigger</h2>
        <p>Definiere Geschenke oder Chat-Befehle, die ein Spiel starten.</p>

        <h3>Neuen Trigger hinzuf√ºgen</h3>
        <div class="form-group">
          <label>Spiel-Typ:</label>
          <select id="triggerGameType">
            <option value="connect4">Connect4</option>
          </select>
        </div>

        <div class="form-group">
          <label>Trigger-Typ:</label>
          <select id="triggerType">
            <option value="gift">Geschenk</option>
            <option value="command">Chat-Befehl</option>
          </select>
        </div>

        <div class="form-group" id="gift-trigger-group">
          <label>Geschenk ausw√§hlen:</label>
          <button id="openGiftCatalogBtn" style="margin-right: 10px;">üì¶ Geschenk-Katalog √∂ffnen</button>
          <button id="refreshGiftCatalogBtn">üîÑ Katalog aktualisieren</button>
          <div id="selected-gift-display" style="margin-top: 10px; padding: 10px; background: #3a3a4e; border-radius: 5px; display: none;">
            <strong>Ausgew√§hltes Geschenk:</strong> <span id="selected-gift-name"></span>
            <input type="hidden" id="triggerValue">
          </div>
        </div>

        <div class="form-group" id="command-trigger-group" style="display: none;">
          <label>Chat-Befehl:</label>
          <input type="text" id="commandTriggerValue" placeholder="z.B. !play">
        </div>

        <button id="addTriggerBtn">Trigger hinzuf√ºgen</button>

        <h3>Aktive Trigger</h3>
        <div class="trigger-list" id="trigger-list">
          <!-- Triggers will be loaded here -->
        </div>
      </div>
    </div>

    <!-- XP Rewards Tab -->
    <div class="tab-content" id="tab-xp-rewards">
      <div class="card">
        <h2>XP-Belohnungen</h2>
        <p>Konfiguriere, wie viel XP Zuschauer f√ºr Siege, Niederlagen und Teilnahme erhalten.</p>

        <h3>Connect4 XP-Belohnungen</h3>
        
        <div class="form-group">
          <label>XP f√ºr Sieg:</label>
          <input type="number" id="winXP" value="100" min="0" step="10">
        </div>

        <div class="form-group">
          <label>XP f√ºr Niederlage:</label>
          <input type="number" id="lossXP" value="25" min="0" step="5">
        </div>

        <div class="form-group">
          <label>XP f√ºr Unentschieden:</label>
          <input type="number" id="drawXP" value="50" min="0" step="10">
        </div>

        <div class="form-group">
          <label>XP f√ºr Teilnahme:</label>
          <input type="number" id="participationXP" value="10" min="0" step="5">
        </div>

        <button id="saveXPRewardsBtn">XP-Belohnungen speichern</button>
      </div>
    </div>

    <!-- ELO System Tab -->
    <div class="tab-content" id="tab-elo">
      <div class="card">
        <h2>‚≠ê ELO Rating System</h2>
        <p>Konfiguriere das ELO-Bewertungssystem f√ºr faire Ranglisten.</p>
        
        <div class="form-group">
          <label>
            <input type="checkbox" id="eloEnabled" checked>
            ELO Rating System aktivieren
          </label>
        </div>

        <div class="form-group">
          <label>Start ELO Rating:</label>
          <input type="number" id="eloStartRating" value="1000" min="100" max="3000" step="100">
          <small>Standard: 1000 (empfohlen f√ºr neue Spieler)</small>
        </div>

        <div class="form-group">
          <label>K-Faktor:</label>
          <input type="number" id="eloKFactor" value="32" min="8" max="64" step="8">
          <small>H√∂herer K-Faktor = gr√∂√üere Rating-√Ñnderungen. Empfohlen: 32 f√ºr neue Spieler, 16 f√ºr erfahrene</small>
        </div>

        <div class="form-group">
          <label>
            <input type="checkbox" id="leaderboardELO" checked>
            ELO Leaderboard in Rotation anzeigen
          </label>
        </div>

        <button id="saveELOSettingsBtn">ELO Einstellungen speichern</button>

        <h3 style="margin-top: 30px;">ELO Rangliste (Top 10)</h3>
        <div id="elo-leaderboard-display">
          <p>Lade ELO Rangliste...</p>
        </div>
      </div>
    </div>

    <!-- Media Tab -->
    <div class="tab-content" id="tab-media">
      <div class="card">
        <h2>üé¨ Game Media Configuration</h2>
        <p>Konfiguriere Audio-Dateien f√ºr alle Spiele. W√§hle das Spiel aus und lade eigene Sounds hoch oder nutze die Default-Sounds.</p>
        
        <div style="background: #3a3a4e; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <h4 style="color: #4CAF50; margin-top: 0;">‚ÑπÔ∏è Default Sounds</h4>
          <p style="margin: 5px 0;">Das System verwendet automatisch Standard-Sounds f√ºr alle Events.</p>
          <p style="margin: 5px 0; color: #888;">Lade eigene Dateien hoch, um die Standard-Sounds zu √ºberschreiben.</p>
          <p style="margin: 5px 0; color: #888;">Wenn keine benutzerdefinierte Datei hochgeladen ist, werden automatisch die Standard-Sounds abgespielt.</p>
        </div>

        <!-- Game Type Selector -->
        <div class="form-group">
          <label><strong>üéÆ Spiel ausw√§hlen:</strong></label>
          <select id="media-game-selector" style="width: 100%; padding: 12px; font-size: 16px; margin-top: 5px;">
            <option value="connect4">üî¥üü° Connect4 / Vier Gewinnt</option>
            <option value="chess">‚ôüÔ∏è Schach / Chess</option>
            <option value="wheel">üé° Gl√ºcksrad / Wheel of Fortune</option>
          </select>
        </div>

        <!-- Connect4 / Chess Media Section -->
        <div id="media-section-connect4">
          <h3>üî¥üü° Connect4 / ‚ôüÔ∏è Chess Sounds</h3>
          <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
            Diese Sounds werden f√ºr Connect4 und Schach verwendet.
          </p>

          <h4>Challenge Events</h4>
          
          <div class="form-group">
            <label>üéµ Neuer Herausforderer (New Challenger):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: new-challenger-alert.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaNewChallenger" accept="audio/*,video/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/default/new-challenger-alert.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaNewChallenger" style="margin-top: 5px; color: #aaa;"></div>
            <button data-upload="new_challenger" data-input="mediaNewChallenger" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="new_challenger" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>üéµ Challenge Akzeptiert (Challenge Accepted):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: challenge accepted.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaChallengeAccepted" accept="audio/*,video/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/default/challenge accepted.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaChallengeAccepted" style="margin-top: 5px; color: #aaa;"></div>
            <button data-upload="challenge_accepted" data-input="mediaChallengeAccepted" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="challenge_accepted" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <h4>Game Event Sounds</h4>
          
          <div class="form-group">
            <label>üîä Spieler 1 gewinnt (Player 1 Wins):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: player-1-wins.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaPlayer1Wins" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/default/player-1-wins.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaPlayer1Wins" style="margin-top: 5px; color: #aaa;"></div>
            <button data-upload="player_1_wins" data-input="mediaPlayer1Wins" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="player_1_wins" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>üèÜ Spieler 2 gewinnt (Player 2 Wins):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: player-2-wins.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaPlayer2Wins" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/default/player-2-wins.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaPlayer2Wins" style="margin-top: 5px; color: #aaa;"></div>
            <button data-upload="player_2_wins" data-input="mediaPlayer2Wins" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="player_2_wins" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>
          
          <div class="form-group">
            <label>ü§ù Unentschieden (Draw/Game Over):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: game over.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaGameOver" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/default/game over.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaGameOver" style="margin-top: 5px; color: #aaa;"></div>
            <button data-upload="game_over" data-input="mediaGameOver" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="game_over" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>üîä Stein f√§llt (Piece Drop / Game Start):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: game start.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaPieceDrop" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/default/game start.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaPieceDrop" style="margin-top: 5px; color: #aaa;"></div>
            <button data-upload="piece_drop" data-input="mediaPieceDrop" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="piece_drop" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>‚è∞ Timer Warnung (10 Sekunden):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: ten-sec-timer.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaTimerWarning" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/default/ten-sec-timer.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaTimerWarning" style="margin-top: 5px; color: #aaa;"></div>
            <button data-upload="timer_warning" data-input="mediaTimerWarning" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="timer_warning" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>
        </div>

        <!-- Wheel (Gl√ºcksrad) Media Section -->
        <div id="media-section-wheel" style="display: none;">
          <h3>üé° Gl√ºcksrad (Wheel of Fortune) Sounds</h3>
          <p style="color: #888; font-size: 14px; margin-bottom: 15px;">
            Diese Sounds werden speziell f√ºr das Gl√ºcksrad verwendet. Die Spin-Dauer wird automatisch an die L√§nge der Spinning-Audio angepasst.
          </p>
          
          <div style="background: #2a4a3e; padding: 12px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #4CAF50;">
            <strong style="color: #4CAF50;">üí° Audio-Pfade:</strong>
            <span style="color: #aaa; font-size: 14px;">
              Die Wheel-spezifischen Sounds befinden sich in <code>/game-engine/sounds/wheel/</code>
            </span>
          </div>

          <div class="form-group">
            <label>üé∞ Spinning Sound (spielt w√§hrend das Rad dreht):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: spinning sound.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaWheelSpinning" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/wheel/spinning sound.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaWheelSpinning" style="margin-top: 5px; color: #4CAF50;">Standard: spinning sound.mp3</div>
            <button data-upload="wheel_spinning" data-input="mediaWheelSpinning" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="wheel_spinning" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>üèÜ Preis 1 Audio (f√ºr Segmente mit Audio=1):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: price 1 audio.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaWheelPrize1" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/wheel/price 1 audio.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaWheelPrize1" style="margin-top: 5px; color: #4CAF50;">Standard: price 1 audio.mp3</div>
            <button data-upload="wheel_prize1" data-input="mediaWheelPrize1" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="wheel_prize1" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>üèÜ Preis 2 Audio (f√ºr Segmente mit Audio=2):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: price 2 audio.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaWheelPrize2" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/wheel/price 2 audio.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaWheelPrize2" style="margin-top: 5px; color: #4CAF50;">Standard: price 2 audio.mp3</div>
            <button data-upload="wheel_prize2" data-input="mediaWheelPrize2" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="wheel_prize2" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>üèÜ Preis 3 Audio (f√ºr Segmente mit Audio=3):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: price 3 audio.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaWheelPrize3" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/wheel/price 3 audio.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaWheelPrize3" style="margin-top: 5px; color: #4CAF50;">Standard: price 3 audio.mp3</div>
            <button data-upload="wheel_prize3" data-input="mediaWheelPrize3" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="wheel_prize3" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>

          <div class="form-group">
            <label>üò¢ Niete/Lost Audio (spielt bei keinem Gewinn):</label>
            <div style="color: #888; font-size: 12px; margin: 5px 0;">Default: lost.mp3</div>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
              <input type="file" id="mediaWheelLost" accept="audio/*" style="flex: 1;">
              <button type="button" class="secondary media-preview-btn" data-audio="/game-engine/sounds/wheel/lost.mp3" style="padding: 8px 15px;" title="Vorschau">‚ñ∂Ô∏è</button>
            </div>
            <div id="currentMediaWheelLost" style="margin-top: 5px; color: #4CAF50;">Standard: lost.mp3</div>
            <button data-upload="wheel_lost" data-input="mediaWheelLost" class="upload-media-btn" style="margin-top: 5px;">Upload Custom</button>
            <button data-delete="wheel_lost" class="delete-media-btn danger" style="margin-top: 5px;">Zur√ºck zu Default</button>
          </div>
          
          <div style="background: #3a3a4e; padding: 12px; border-radius: 8px; margin-top: 15px;">
            <strong style="color: #64B5F6;">‚ÑπÔ∏è Hinweis zu Wheel-spezifischen Audios:</strong>
            <p style="color: #aaa; font-size: 14px; margin: 5px 0 0 0;">
              Wenn du individuelle Audios pro Wheel konfigurieren m√∂chtest, nutze die Audio-Einstellungen im Tab "üé° Gl√ºcksrad" f√ºr das jeweilige Wheel.
              Die hier konfigurierten Audios sind die globalen Defaults f√ºr alle Wheels.
            </p>
          </div>
        </div>

        <p style="margin-top: 20px; color: #888;">
          <strong>Hinweis:</strong> Unterst√ºtzte Formate: MP3, WAV, OGG f√ºr Audio; MP4, WebM f√ºr Video.
          Benutzerdefinierte Dateien werden im Plugin-Datenverzeichnis gespeichert und √ºberschreiben die Standard-Sounds.
        </p>
      </div>
    </div>

    <!-- Stats Tab -->
    <div class="tab-content" id="tab-stats">
      <div class="card">
        <h2>Statistiken</h2>
        
        <h3>Connect4 Statistiken</h3>
        <div class="stats-grid" id="stats-grid">
          <!-- Stats will be loaded here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Gift Catalog Modal -->
  <div id="gift-catalog-modal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h3>üéÅ Geschenk-Katalog</h3>
        <button class="modal-close" id="closeGiftCatalogBtn">‚úï</button>
      </div>
      <div class="catalog-info" id="catalog-info">
        Lade Geschenk-Katalog...
      </div>
      <div class="gift-grid" id="gift-grid">
        <!-- Gifts will be loaded here -->
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="/js/i18n-client.js"></script>
  <script src="/js/theme-manager.js"></script>
  <script src="/js/language-switcher.js"></script>
  <script>
    const socket = io();
    let currentSessionId = null;
    let gameEngineThemeManager = null; // Local theme manager for game engine

    // Initialize theme and language switcher
    // Note: i18n is auto-initialized by i18n-client.js
    (async function initApp() {
      try {
        // Wait for i18n to be ready (it auto-initializes via i18n-client.js)
        if (window.i18n && !window.i18n.initialized) {
          await window.i18n.init();
        }
        
        // Initialize theme manager (automatically applies saved theme)
        if (typeof ThemeManager !== 'undefined') {
          window.themeManager = new ThemeManager();
        }
        
        // Initialize game engine specific theme manager (Feature #1)
        if (typeof ThemeManager !== 'undefined') {
          gameEngineThemeManager = new ThemeManager();
          gameEngineThemeManager.init();
          
          // Set up theme toggle buttons
          setupThemeToggle();
        }
        
        // Initialize language switcher (automatically sets up UI)
        if (typeof LanguageSwitcher !== 'undefined') {
          window.languageSwitcher = new LanguageSwitcher();
        }
        
        console.log('‚úÖ Game Engine UI initialized with i18n and theme support');
      } catch (error) {
        console.error('Failed to initialize app:', error);
      }
    })();

    // Setup theme toggle buttons (Feature #1)
    function setupThemeToggle() {
      const themeButtons = document.querySelectorAll('.theme-toggle-btn');
      
      // Update button states based on current theme
      function updateThemeButtons(theme) {
        themeButtons.forEach(btn => {
          if (btn.dataset.theme === theme) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
      
      // Set initial state
      updateThemeButtons(gameEngineThemeManager.getCurrentTheme());
      
      // Add click handlers
      themeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const theme = btn.dataset.theme;
          gameEngineThemeManager.setTheme(theme);
          updateThemeButtons(theme);
        });
      });
      
      // Listen for theme changes from other sources
      window.addEventListener('theme-changed', (e) => {
        updateThemeButtons(e.detail.theme);
      });
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        tab.classList.add('active');
        document.getElementById(`tab-${tabName}`).classList.add('active');
      });
    });

    // Show message
    function showMessage(message, type = 'success') {
      const msgEl = document.getElementById(`${type}-message`);
      msgEl.textContent = message;
      msgEl.classList.add('show');
      setTimeout(() => msgEl.classList.remove('show'), 3000);
    }

    // Color picker preview updates
    ['board', 'player1', 'player2', 'text'].forEach(prefix => {
      const input = document.getElementById(`${prefix}Color`);
      const preview = document.getElementById(`${prefix}ColorPreview`);
      if (input && preview) {
        input.addEventListener('input', () => {
          preview.style.background = input.value;
        });
        preview.style.background = input.value;
      }
    });

    // Save settings
    async function saveSettings() {
      // Collect leaderboard types
      const leaderboardTypes = [];
      if (document.getElementById('leaderboardDaily').checked) leaderboardTypes.push('daily');
      if (document.getElementById('leaderboardSeason').checked) leaderboardTypes.push('season');
      if (document.getElementById('leaderboardLifetime').checked) leaderboardTypes.push('lifetime');
      if (document.getElementById('leaderboardELORotation').checked) leaderboardTypes.push('elo');

      const config = {
        boardColor: document.getElementById('boardColor').value,
        player1Color: document.getElementById('player1Color').value,
        player2Color: document.getElementById('player2Color').value,
        textColor: document.getElementById('textColor').value,
        fontFamily: document.getElementById('fontFamily').value,
        showCoordinates: document.getElementById('showCoordinates').checked,
        animationSpeed: parseInt(document.getElementById('animationSpeed').value),
        streamerRole: document.getElementById('streamerRole').value,
        chatCommand: (() => {
          const cmd = document.getElementById('c4ChatCommand').value.trim();
          // Validate command: only alphanumeric, underscore, and hyphen
          if (cmd && !/^[a-zA-Z0-9_-]+$/.test(cmd)) {
            showMessage('Fehler: Chat-Befehl darf nur Buchstaben, Zahlen, Unterstrich und Bindestrich enthalten', 'error');
            throw new Error('Invalid chat command');
          }
          return cmd || 'c4start';
        })(),
        showChallengeScreen: document.getElementById('showChallengeScreen').checked,
        challengeTimeout: parseInt(document.getElementById('challengeTimeout').value),
        leaderboardEnabled: document.getElementById('leaderboardEnabled').checked,
        leaderboardDisplayTime: parseInt(document.getElementById('leaderboardDisplayTime').value),
        leaderboardTypes: leaderboardTypes,
        roundTimerEnabled: document.getElementById('roundTimerEnabled').checked,
        roundTimeLimit: parseInt(document.getElementById('roundTimeLimit').value),
        roundWarningTime: parseInt(document.getElementById('roundWarningTime').value)
      };

      try {
        const res = await fetch('/api/game-engine/config/connect4', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });

        if (res.ok) {
          showMessage('Einstellungen gespeichert!');
          
          // Also save round timer config
          await saveRoundTimerConfig();
          
          // Trigger GCCE command re-registration by emitting socket event
          socket.emit('game-engine:config-updated', { gameType: 'connect4' });
        } else {
          showMessage('Fehler beim Speichern', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }
    
    // Save round timer configuration separately
    async function saveRoundTimerConfig() {
      const timerConfig = {
        enabled: document.getElementById('roundTimerEnabled').checked,
        timeLimitSeconds: parseInt(document.getElementById('roundTimeLimit').value),
        warningTimeSeconds: parseInt(document.getElementById('roundWarningTime').value)
      };
      
      try {
        await fetch('/api/game-engine/round-timer/connect4', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(timerConfig)
        });
      } catch (error) {
        console.error('Failed to save round timer config:', error);
      }
    }

    // Load settings
    async function loadSettings() {
      try {
        const res = await fetch('/api/game-engine/config/connect4');
        const config = await res.json();

        if (config.boardColor) document.getElementById('boardColor').value = config.boardColor;
        if (config.player1Color) document.getElementById('player1Color').value = config.player1Color;
        if (config.player2Color) document.getElementById('player2Color').value = config.player2Color;
        if (config.textColor) document.getElementById('textColor').value = config.textColor;
        if (config.fontFamily) document.getElementById('fontFamily').value = config.fontFamily;
        if (config.showCoordinates !== undefined) document.getElementById('showCoordinates').checked = config.showCoordinates;
        if (config.animationSpeed) document.getElementById('animationSpeed').value = config.animationSpeed;
        if (config.streamerRole) document.getElementById('streamerRole').value = config.streamerRole;
        
        // Chat command setting
        if (config.chatCommand) document.getElementById('c4ChatCommand').value = config.chatCommand;
        
        // Challenge flow settings
        if (config.showChallengeScreen !== undefined) document.getElementById('showChallengeScreen').checked = config.showChallengeScreen;
        if (config.challengeTimeout) document.getElementById('challengeTimeout').value = config.challengeTimeout;
        
        // Leaderboard settings
        if (config.leaderboardEnabled !== undefined) document.getElementById('leaderboardEnabled').checked = config.leaderboardEnabled;
        if (config.leaderboardDisplayTime) document.getElementById('leaderboardDisplayTime').value = config.leaderboardDisplayTime;
        
        // Leaderboard types
        if (config.leaderboardTypes) {
          document.getElementById('leaderboardDaily').checked = config.leaderboardTypes.includes('daily');
          document.getElementById('leaderboardSeason').checked = config.leaderboardTypes.includes('season');
          document.getElementById('leaderboardLifetime').checked = config.leaderboardTypes.includes('lifetime');
          document.getElementById('leaderboardELORotation').checked = config.leaderboardTypes.includes('elo');
        }
        
        // Round timer settings
        if (config.roundTimerEnabled !== undefined) document.getElementById('roundTimerEnabled').checked = config.roundTimerEnabled;
        if (config.roundTimeLimit) document.getElementById('roundTimeLimit').value = config.roundTimeLimit;
        if (config.roundWarningTime) document.getElementById('roundWarningTime').value = config.roundWarningTime;

        // Update color previews
        ['board', 'player1', 'player2', 'text'].forEach(prefix => {
          const input = document.getElementById(`${prefix}Color`);
          const preview = document.getElementById(`${prefix}ColorPreview`);
          if (input && preview) {
            preview.style.background = input.value;
          }
        });
      } catch (error) {
        console.error('Failed to load settings:', error);
      }
    }

    // Chess settings functions
    async function saveChessSettings() {
      const config = {
        defaultTimeControl: document.getElementById('chess-time-control').value,
        streamerRole: document.getElementById('chess-streamer-role').value,
        timerWarningTime: parseInt(document.getElementById('chess-timer-warning').value),
        boardTheme: document.getElementById('chess-board-theme').value,
        backgroundColor: document.getElementById('chess-bg-color').value,
        whiteColor: document.getElementById('chess-white-color').value,
        blackColor: document.getElementById('chess-black-color').value,
        showCoordinates: document.getElementById('chess-show-coordinates').checked,
        highlightLastMove: document.getElementById('chess-highlight-last-move').checked,
        highlightCheck: document.getElementById('chess-highlight-check').checked,
        showCapturedPieces: document.getElementById('chess-show-captured').checked,
        animationSpeed: parseInt(document.getElementById('chess-animation-speed').value),
        soundEnabled: document.getElementById('chess-sound-enabled').checked,
        soundVolume: parseFloat(document.getElementById('chess-sound-volume').value),
        celebrationEnabled: document.getElementById('chess-celebration-enabled').checked,
        showChallengeScreen: document.getElementById('chess-challenge-screen').checked,
        challengeTimeout: parseInt(document.getElementById('chess-challenge-timeout').value),
        leaderboardEnabled: document.getElementById('chess-leaderboard-enabled').checked,
        leaderboardDisplayTime: parseInt(document.getElementById('chess-leaderboard-display-time').value),
        eloEnabled: document.getElementById('chess-elo-enabled').checked,
        eloStartRating: parseInt(document.getElementById('chess-elo-start').value),
        eloKFactor: parseInt(document.getElementById('chess-elo-k-factor').value)
      };

      try {
        const res = await fetch('/api/game-engine/config/chess', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });

        if (res.ok) {
          showMessage('Schach-Einstellungen gespeichert!');
        } else {
          showMessage('Fehler beim Speichern', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function loadChessSettings() {
      try {
        const res = await fetch('/api/game-engine/config/chess');
        const config = await res.json();

        if (config.defaultTimeControl) document.getElementById('chess-time-control').value = config.defaultTimeControl;
        if (config.streamerRole) document.getElementById('chess-streamer-role').value = config.streamerRole;
        if (config.timerWarningTime) document.getElementById('chess-timer-warning').value = config.timerWarningTime;
        if (config.boardTheme) document.getElementById('chess-board-theme').value = config.boardTheme;
        if (config.backgroundColor) document.getElementById('chess-bg-color').value = config.backgroundColor;
        if (config.whiteColor) document.getElementById('chess-white-color').value = config.whiteColor;
        if (config.blackColor) document.getElementById('chess-black-color').value = config.blackColor;
        if (config.showCoordinates !== undefined) document.getElementById('chess-show-coordinates').checked = config.showCoordinates;
        if (config.highlightLastMove !== undefined) document.getElementById('chess-highlight-last-move').checked = config.highlightLastMove;
        if (config.highlightCheck !== undefined) document.getElementById('chess-highlight-check').checked = config.highlightCheck;
        if (config.showCapturedPieces !== undefined) document.getElementById('chess-show-captured').checked = config.showCapturedPieces;
        if (config.animationSpeed) document.getElementById('chess-animation-speed').value = config.animationSpeed;
        if (config.soundEnabled !== undefined) document.getElementById('chess-sound-enabled').checked = config.soundEnabled;
        if (config.soundVolume !== undefined) {
          document.getElementById('chess-sound-volume').value = config.soundVolume;
          document.getElementById('chess-volume-display').textContent = Math.round(config.soundVolume * 100) + '%';
        }
        if (config.celebrationEnabled !== undefined) document.getElementById('chess-celebration-enabled').checked = config.celebrationEnabled;
        if (config.showChallengeScreen !== undefined) document.getElementById('chess-challenge-screen').checked = config.showChallengeScreen;
        if (config.challengeTimeout) document.getElementById('chess-challenge-timeout').value = config.challengeTimeout;
        if (config.leaderboardEnabled !== undefined) document.getElementById('chess-leaderboard-enabled').checked = config.leaderboardEnabled;
        if (config.leaderboardDisplayTime) document.getElementById('chess-leaderboard-display-time').value = config.leaderboardDisplayTime;
        if (config.eloEnabled !== undefined) document.getElementById('chess-elo-enabled').checked = config.eloEnabled;
        if (config.eloStartRating) document.getElementById('chess-elo-start').value = config.eloStartRating;
        if (config.eloKFactor) document.getElementById('chess-elo-k-factor').value = config.eloKFactor;
      } catch (error) {
        console.error('Failed to load chess settings:', error);
      }
    }

    // Gift catalog functions
    let giftCatalog = [];

    function updateTriggerInputType() {
      const triggerType = document.getElementById('triggerType').value;
      const giftGroup = document.getElementById('gift-trigger-group');
      const commandGroup = document.getElementById('command-trigger-group');
      
      if (triggerType === 'gift') {
        giftGroup.style.display = 'block';
        commandGroup.style.display = 'none';
      } else {
        giftGroup.style.display = 'none';
        commandGroup.style.display = 'block';
      }
    }

    async function openGiftCatalog() {
      const modal = document.getElementById('gift-catalog-modal');
      modal.classList.add('show');
      await loadGiftCatalogData();
    }

    function closeGiftCatalog() {
      const modal = document.getElementById('gift-catalog-modal');
      modal.classList.remove('show');
    }

    async function loadGiftCatalogData() {
      const infoDiv = document.getElementById('catalog-info');
      const gridDiv = document.getElementById('gift-grid');
      
      try {
        const response = await fetch('/api/gift-catalog');
        const data = await response.json();
        
        if (!data.success) {
          infoDiv.innerHTML = '<span style="color: #f44336;">Fehler beim Laden des Katalogs</span>';
          gridDiv.innerHTML = '';
          return;
        }
        
        giftCatalog = data.catalog || [];
        const lastUpdate = data.lastUpdate;
        
        if (giftCatalog.length === 0) {
          infoDiv.innerHTML = '<span style="color: #FFC107;">‚ö†Ô∏è Keine Geschenke im Katalog. Verbinde mit einem Stream und klicke "Katalog aktualisieren"</span>';
          gridDiv.innerHTML = '';
          return;
        }
        
        const updateText = lastUpdate ? `Zuletzt aktualisiert: ${new Date(lastUpdate).toLocaleString('de-DE')}` : 'Nie aktualisiert';
        infoDiv.innerHTML = `
          <span style="color: #4CAF50;">‚úÖ ${giftCatalog.length} Geschenke verf√ºgbar</span>
          <span style="margin: 0 10px;">‚Ä¢</span>
          <span style="color: #aaa;">${updateText}</span>
        `;
        
        // Render gift grid
        gridDiv.innerHTML = '';
        giftCatalog.forEach(gift => {
          const giftCard = document.createElement('div');
          giftCard.className = 'gift-card';
          giftCard.dataset.giftId = gift.id;
          giftCard.dataset.giftName = gift.name;
          
          giftCard.innerHTML = `
            ${gift.image_url 
              ? `<img src="${gift.image_url}" alt="${gift.name}">`
              : `<div class="gift-placeholder">üéÅ</div>`
            }
            <div class="gift-name">${gift.name}</div>
            <div class="gift-id">ID: ${gift.id}</div>
          `;
          gridDiv.appendChild(giftCard);
        });
        
        // Add event listener for gift cards
        gridDiv.addEventListener('click', (e) => {
          const giftCard = e.target.closest('.gift-card');
          if (giftCard) {
            const gift = {
              id: giftCard.dataset.giftId,
              name: giftCard.dataset.giftName
            };
            selectGiftFromCatalog(gift);
          }
        });
      } catch (error) {
        console.error('Failed to load gift catalog:', error);
        infoDiv.innerHTML = '<span style="color: #f44336;">‚ùå Fehler beim Laden des Katalogs</span>';
      }
    }

    function selectGiftFromCatalog(gift) {
      // Set trigger value to gift ID
      document.getElementById('triggerValue').value = String(gift.id);
      
      // Update display
      const displayDiv = document.getElementById('selected-gift-display');
      const nameSpan = document.getElementById('selected-gift-name');
      nameSpan.textContent = `${gift.name} (ID: ${gift.id})`;
      displayDiv.style.display = 'block';
      
      // Close modal
      closeGiftCatalog();
      
      showMessage(`Geschenk "${gift.name}" ausgew√§hlt`);
    }

    async function refreshGiftCatalog() {
      const infoDiv = document.getElementById('catalog-info');
      
      infoDiv.innerHTML = '<span style="color: #64B5F6;">üîÑ Aktualisiere Katalog...</span>';
      
      try {
        const response = await fetch('/api/gift-catalog/update', {
          method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
          showMessage('Geschenk-Katalog aktualisiert!');
          if (document.getElementById('gift-catalog-modal').classList.contains('show')) {
            await loadGiftCatalogData();
          }
        } else {
          showMessage('Fehler beim Aktualisieren: ' + (result.error || 'Unbekannter Fehler'), 'error');
        }
      } catch (error) {
        console.error('Error refreshing gift catalog:', error);
        showMessage('Fehler beim Aktualisieren des Katalogs', 'error');
      }
    }

    // Add trigger
    async function addTrigger() {
      const gameType = document.getElementById('triggerGameType').value;
      const triggerType = document.getElementById('triggerType').value;
      let triggerValue;
      
      if (triggerType === 'gift') {
        triggerValue = document.getElementById('triggerValue').value.trim();
      } else {
        triggerValue = document.getElementById('commandTriggerValue').value.trim();
      }

      if (!triggerValue) {
        showMessage('Bitte Trigger-Wert eingeben', 'error');
        return;
      }

      try {
        const res = await fetch('/api/game-engine/triggers', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ gameType, triggerType, triggerValue })
        });

        if (res.ok) {
          showMessage('Trigger hinzugef√ºgt!');
          document.getElementById('triggerValue').value = '';
          document.getElementById('commandTriggerValue').value = '';
          document.getElementById('selected-gift-display').style.display = 'none';
          loadTriggers();
        } else {
          showMessage('Fehler beim Hinzuf√ºgen', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    // Load triggers
    async function loadTriggers() {
      try {
        const res = await fetch('/api/game-engine/triggers');
        const triggers = await res.json();

        const listEl = document.getElementById('trigger-list');
        listEl.innerHTML = '';

        if (triggers.length === 0) {
          listEl.innerHTML = '<p>Keine Trigger konfiguriert</p>';
          return;
        }

        // Fetch gift catalog to display gift names
        let giftLookup = {};
        try {
          const catalogRes = await fetch('/api/gift-catalog');
          const catalogData = await catalogRes.json();
          if (catalogData.success && catalogData.catalog) {
            catalogData.catalog.forEach(gift => {
              giftLookup[String(gift.id)] = gift.name;
            });
          }
        } catch (e) {
          console.warn('Could not load gift catalog for trigger display:', e);
        }

        triggers.forEach(trigger => {
          let displayValue = trigger.trigger_value;
          
          // If it's a gift trigger and we have a numeric ID, show the name
          if (trigger.trigger_type === 'gift') {
            const giftName = giftLookup[trigger.trigger_value];
            if (giftName) {
              displayValue = `${giftName} (ID: ${trigger.trigger_value})`;
            }
          }
          
          const item = document.createElement('div');
          item.className = 'trigger-item';
          item.innerHTML = `
            <div>
              <strong>${trigger.game_type}</strong> - ${trigger.trigger_type}: ${displayValue}
            </div>
            <button class="danger remove-trigger-btn" data-trigger-id="${trigger.id}">Entfernen</button>
          `;
          listEl.appendChild(item);
        });
      } catch (error) {
        console.error('Failed to load triggers:', error);
      }
    }

    // Remove trigger
    async function removeTrigger(triggerId) {
      try {
        const res = await fetch(`/api/game-engine/triggers/${triggerId}`, {
          method: 'DELETE'
        });

        if (res.ok) {
          showMessage('Trigger entfernt!');
          loadTriggers();
        } else {
          showMessage('Fehler beim Entfernen', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    // Save XP rewards
    async function saveXPRewards() {
      const rewards = {
        winXP: parseInt(document.getElementById('winXP').value),
        lossXP: parseInt(document.getElementById('lossXP').value),
        drawXP: parseInt(document.getElementById('drawXP').value),
        participationXP: parseInt(document.getElementById('participationXP').value)
      };

      try {
        const res = await fetch('/api/game-engine/xp-rewards/connect4', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(rewards)
        });

        if (res.ok) {
          showMessage('XP-Belohnungen gespeichert!');
        } else {
          showMessage('Fehler beim Speichern', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    // Load XP rewards
    async function loadXPRewards() {
      try {
        const res = await fetch('/api/game-engine/xp-rewards/connect4');
        const rewards = await res.json();

        if (rewards.win_xp !== undefined) document.getElementById('winXP').value = rewards.win_xp;
        if (rewards.loss_xp !== undefined) document.getElementById('lossXP').value = rewards.loss_xp;
        if (rewards.draw_xp !== undefined) document.getElementById('drawXP').value = rewards.draw_xp;
        if (rewards.participation_xp !== undefined) document.getElementById('participationXP').value = rewards.participation_xp;
      } catch (error) {
        console.error('Failed to load XP rewards:', error);
      }
    }

    // Load stats
    async function loadStats() {
      try {
        const res = await fetch('/api/game-engine/stats/connect4');
        
        // Check if response is ok and has content
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        
        const text = await res.text();
        
        // Check if response is empty or not valid JSON
        if (!text || text.trim() === '') {
          console.warn('Empty response from stats API');
          const gridEl = document.getElementById('stats-grid');
          gridEl.innerHTML = '<p>Keine Statistiken verf√ºgbar</p>';
          return;
        }
        
        const stats = JSON.parse(text);

        const gridEl = document.getElementById('stats-grid');
        gridEl.innerHTML = '';

        if (stats) {
          gridEl.innerHTML = `
            <div class="stat-card">
              <div class="stat-value">${stats.total_games || 0}</div>
              <div class="stat-label">Gesamt Spiele</div>
            </div>
            <div class="stat-card">
              <div class="stat-value">${stats.completed_games || 0}</div>
              <div class="stat-label">Abgeschlossene Spiele</div>
            </div>
            <div class="stat-card">
              <div class="stat-value">${stats.active_games || 0}</div>
              <div class="stat-label">Aktive Spiele</div>
            </div>
          `;
        }
      } catch (error) {
        console.error('Failed to load stats:', error);
        const gridEl = document.getElementById('stats-grid');
        if (gridEl) {
          gridEl.innerHTML = '<p>Fehler beim Laden der Statistiken</p>';
        }
      }
    }

    // Make streamer move
    function makeStreamerMove(column) {
      if (!currentSessionId) {
        showMessage('Kein aktives Spiel', 'error');
        return;
      }

      socket.emit('game-engine:streamer-move', {
        sessionId: currentSessionId,
        column: column
      });
    }

    // Cancel game
    function cancelGame() {
      if (!currentSessionId) {
        showMessage('Kein aktives Spiel', 'error');
        return;
      }

      if (confirm('M√∂chtest du das Spiel wirklich abbrechen?')) {
        socket.emit('game-engine:cancel-game', {
          sessionId: currentSessionId
        });
      }
    }

    // Update active game display
    function updateActiveGame(data) {
      currentSessionId = data.sessionId;
      document.getElementById('no-game').style.display = 'none';
      document.getElementById('active-game').classList.add('show');

      const state = data.state;
      const currentPlayer = state.currentPlayer === 1 ? state.player1 : state.player2;
      
      document.getElementById('game-status').textContent = 
        `Am Zug: ${currentPlayer.nickname || currentPlayer.username} (${currentPlayer.role === 'streamer' ? 'Du' : 'Zuschauer'})`;

      // Update board preview (simple text representation for now)
      const boardEl = document.getElementById('board-preview');
      boardEl.innerHTML = '<pre>' + getBoardText(state.board, state.player1.color, state.player2.color) + '</pre>';
    }

    // Get board as text
    function getBoardText(board, color1, color2) {
      let text = '  A B C D E F G\n';
      for (let r = 0; r < 6; r++) {
        text += `${r + 1} `;
        for (let c = 0; c < 7; c++) {
          const cell = board[r][c];
          text += cell === 0 ? '¬∑ ' : (cell === 1 ? '‚óØ ' : '‚óâ ');
        }
        text += '\n';
      }
      return text;
    }

    // Clear active game display
    function clearActiveGame() {
      currentSessionId = null;
      document.getElementById('no-game').style.display = 'block';
      document.getElementById('active-game').classList.remove('show');
    }

    // Socket events
    socket.on('game-engine:challenge-created', (data) => {
      // Show notification about new challenge
      showMessage(`Neue Herausforderung von ${data.challengerNickname || data.challengerUsername}!`);
    });

    socket.on('game-engine:game-started', (data) => {
      updateActiveGame(data);
      loadStats();
    });

    socket.on('game-engine:move-made', (data) => {
      if (data.sessionId === currentSessionId) {
        updateActiveGame(data);
      }
    });

    socket.on('game-engine:game-ended', (data) => {
      if (data.sessionId === currentSessionId) {
        clearActiveGame();
        loadStats();
      }
    });

    socket.on('game-engine:error', (data) => {
      showMessage(data.error, 'error');
    });

    // Check for active session on load
    async function checkActiveSession() {
      try {
        const res = await fetch('/api/game-engine/active-session');
        const data = await res.json();

        if (data && data.sessionId) {
          updateActiveGame(data);
        }
      } catch (error) {
        console.error('Failed to check active session:', error);
      }
    }

    // ELO Settings Functions
    async function saveELOSettings() {
      const config = {
        eloEnabled: document.getElementById('eloEnabled').checked,
        eloStartRating: parseInt(document.getElementById('eloStartRating').value),
        eloKFactor: parseInt(document.getElementById('eloKFactor').value),
        leaderboardTypes: [] // Will be handled in main saveSettings
      };
      
      // Merge with existing config
      try {
        const existing = await fetch('/api/game-engine/config/connect4').then(r => r.json());
        Object.assign(existing, config);
        
        const res = await fetch('/api/game-engine/config/connect4', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(existing)
        });
        
        if (res.ok) {
          showMessage('ELO Einstellungen gespeichert!');
          loadELOLeaderboard();
        } else {
          showMessage('Fehler beim Speichern', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }
    
    async function loadELOLeaderboard() {
      const display = document.getElementById('elo-leaderboard-display');
      
      try {
        const res = await fetch('/api/game-engine/elo-leaderboard/connect4?limit=10');
        const data = await res.json();
        
        if (data.length === 0) {
          display.innerHTML = '<p>Noch keine ELO-Daten verf√ºgbar.</p>';
          return;
        }
        
        let html = '<table style="width: 100%; border-collapse: collapse;">';
        html += '<thead><tr style="background: #3a3a4e;"><th style="padding: 10px; text-align: left;">Rang</th><th>Spieler</th><th>ELO</th><th>Peak ELO</th><th>Spiele</th></tr></thead>';
        html += '<tbody>';
        
        data.forEach((player, index) => {
          const rank = index + 1;
          const icon = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank;
          html += `<tr style="background: ${index % 2 === 0 ? '#2a2a3e' : '#3a3a4e'};">`;
          html += `<td style="padding: 10px;">${icon}</td>`;
          html += `<td>${player.username}</td>`;
          html += `<td><strong>${player.elo_rating || 1000}</strong></td>`;
          html += `<td>${player.peak_elo || 1000}</td>`;
          html += `<td>${player.total_games || 0}</td>`;
          html += '</tr>';
        });
        
        html += '</tbody></table>';
        display.innerHTML = html;
      } catch (error) {
        display.innerHTML = '<p>Fehler beim Laden der ELO-Rangliste.</p>';
        console.error('Failed to load ELO leaderboard:', error);
      }
    }
    
    // Media Upload Functions
    async function uploadMedia(eventType, fileInputId) {
      // Dispatch to wheel-specific handler for wheel audio types
      if (eventType.startsWith('wheel_')) {
        await uploadWheelMedia(eventType, fileInputId);
        return;
      }
      
      const fileInput = document.getElementById(fileInputId);
      const file = fileInput.files[0];
      
      if (!file) {
        showMessage('Bitte w√§hle eine Datei aus', 'error');
        return;
      }
      
      showMessage('Uploading... (Not fully implemented - requires file upload endpoint)', 'error');
      
      // Note: This is a placeholder. Full implementation would require:
      // 1. FormData to upload file to server
      // 2. Server endpoint to save file to plugin data directory
      // 3. Return file path and save to database
      
      // For now, just show the structure:
      const formData = new FormData();
      formData.append('file', file);
      
      try {
        // This endpoint would need to be implemented to handle file uploads
        const response = await fetch(`/api/game-engine/media/connect4/${eventType}`, {
          method: 'POST',
          body: formData
        });
        
        if (response.ok) {
          showMessage('Media hochgeladen!');
          loadCurrentMedia();
        } else {
          showMessage('Fehler beim Hochladen', 'error');
        }
      } catch (error) {
        showMessage('Upload-Feature requires server-side file handling', 'error');
        console.error('Upload error:', error);
      }
    }
    
    async function deleteMedia(eventType) {
      // Dispatch to wheel-specific handler for wheel audio types
      if (eventType.startsWith('wheel_')) {
        await deleteWheelMedia(eventType);
        return;
      }
      
      if (!confirm('Media-Datei wirklich l√∂schen?')) return;
      
      try {
        const response = await fetch(`/api/game-engine/media/connect4/${eventType}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          showMessage('Media gel√∂scht!');
          loadCurrentMedia();
        } else {
          showMessage('Fehler beim L√∂schen', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }
    
    async function loadCurrentMedia() {
      try {
        const response = await fetch('/api/game-engine/media/connect4');
        const media = await response.json();
        
        // Define all event types with their display IDs
        const eventTypes = [
          { event: 'new_challenger', displayId: 'currentMediaNewChallenger' },
          { event: 'challenge_accepted', displayId: 'currentMediaChallengeAccepted' },
          { event: 'piece_drop', displayId: 'currentMediaPieceDrop' },
          { event: 'player_1_wins', displayId: 'currentMediaPlayer1Wins' },
          { event: 'player_2_wins', displayId: 'currentMediaPlayer2Wins' },
          { event: 'game_over', displayId: 'currentMediaGameOver' },
          { event: 'timer_warning', displayId: 'currentMediaTimerWarning' }
        ];
        
        // Clear all displays and show default info
        eventTypes.forEach(({ displayId }) => {
          const display = document.getElementById(displayId);
          if (display) display.innerHTML = '<span style="color: #4CAF50;">‚úì Standard-Sound aktiv</span>';
        });
        
        // Show custom media if configured
        media.forEach(m => {
          const eventType = eventTypes.find(e => e.event === m.media_event);
          if (eventType) {
            const display = document.getElementById(eventType.displayId);
            if (display) {
              display.innerHTML = `<span style="color: #FFC107;">üìÅ Custom: ${m.file_path.split('/').pop()} (${m.media_type})</span>`;
            }
          }
        });
      } catch (error) {
        console.error('Failed to load current media:', error);
      }
    }

    // ===========================================
    // Media Tab Game Selector & Preview Functions
    // ===========================================

    // Constants for Media tab
    const DEFAULT_WHEEL_ID = '1'; // Global default wheel ID for media configuration
    
    // Track current media preview audio element
    let mediaPreviewAudioElement = null;

    // Handle media game selector change
    function handleMediaGameSelectorChange() {
      const selector = document.getElementById('media-game-selector');
      if (!selector) return;

      selector.addEventListener('change', (e) => {
        const selectedGame = e.target.value;
        
        // Hide all media sections
        document.getElementById('media-section-connect4').style.display = 'none';
        document.getElementById('media-section-wheel').style.display = 'none';
        
        // Show selected section
        if (selectedGame === 'wheel') {
          document.getElementById('media-section-wheel').style.display = 'block';
          loadWheelMediaSettings();
        } else {
          // Connect4 and Chess share the same audio section
          document.getElementById('media-section-connect4').style.display = 'block';
        }
      });
    }

    // Load wheel media settings for the Media tab
    async function loadWheelMediaSettings() {
      try {
        const response = await fetch(`/api/game-engine/wheel/audio/settings?wheelId=${DEFAULT_WHEEL_ID}`);
        const settings = await response.json();
        
        const audioTypes = [
          { type: 'spinning', displayId: 'currentMediaWheelSpinning', defaultName: 'spinning sound.mp3' },
          { type: 'prize1', displayId: 'currentMediaWheelPrize1', defaultName: 'price 1 audio.mp3' },
          { type: 'prize2', displayId: 'currentMediaWheelPrize2', defaultName: 'price 2 audio.mp3' },
          { type: 'prize3', displayId: 'currentMediaWheelPrize3', defaultName: 'price 3 audio.mp3' },
          { type: 'lost', displayId: 'currentMediaWheelLost', defaultName: 'lost.mp3' }
        ];
        
        audioTypes.forEach(({ type, displayId, defaultName }) => {
          const display = document.getElementById(displayId);
          if (!display) return;
          
          const setting = settings[type];
          if (setting && setting.isCustom && setting.filename) {
            display.innerHTML = `<span style="color: #2196F3;">Custom: ${setting.filename}</span>`;
          } else {
            display.innerHTML = `<span style="color: #4CAF50;">Standard: ${defaultName}</span>`;
          }
        });
      } catch (error) {
        console.error('Error loading wheel media settings:', error);
      }
    }

    // Preview audio from the media tab
    function previewMediaAudio(audioPath) {
      // Stop any currently playing audio
      if (mediaPreviewAudioElement) {
        mediaPreviewAudioElement.pause();
        mediaPreviewAudioElement = null;
      }
      
      const audio = new Audio(audioPath);
      audio.volume = 0.5;
      audio.play().catch(err => {
        console.warn('Audio preview failed:', err);
        showMessage('Audio konnte nicht abgespielt werden', 'error');
      });
      
      mediaPreviewAudioElement = audio;
    }

    // Handle media preview button clicks (event delegation)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('media-preview-btn')) {
        const audioPath = e.target.dataset.audio;
        if (audioPath) {
          previewMediaAudio(audioPath);
        }
      }
    });

    // Upload wheel-specific media (from Media tab)
    async function uploadWheelMedia(audioType, fileInputId) {
      const fileInput = document.getElementById(fileInputId);
      const file = fileInput.files[0];
      
      if (!file) {
        showMessage('Bitte w√§hle eine Datei aus', 'error');
        return;
      }
      
      // Map audioType to the correct type names
      const typeMap = {
        'wheel_spinning': 'spinning',
        'wheel_prize1': 'prize1',
        'wheel_prize2': 'prize2',
        'wheel_prize3': 'prize3',
        'wheel_lost': 'lost'
      };
      
      const mappedType = typeMap[audioType];
      if (!mappedType) {
        showMessage('Unbekannter Audio-Typ', 'error');
        return;
      }
      
      const formData = new FormData();
      formData.append('audio', file);
      formData.append('audioType', mappedType);
      formData.append('wheelId', DEFAULT_WHEEL_ID);
      
      try {
        const response = await fetch('/api/game-engine/wheel/audio/upload', {
          method: 'POST',
          body: formData
        });
        
        const data = await response.json();
        if (data.success) {
          showMessage(`Audio "${mappedType}" erfolgreich hochgeladen!`);
          loadWheelMediaSettings();
        } else {
          showMessage(`Fehler: ${data.error}`, 'error');
        }
      } catch (error) {
        showMessage(`Upload-Fehler: ${error.message}`, 'error');
      }
    }

    // Delete wheel-specific media (reset to default)
    async function deleteWheelMedia(audioType) {
      // Map audioType to the correct type names
      const typeMap = {
        'wheel_spinning': 'spinning',
        'wheel_prize1': 'prize1',
        'wheel_prize2': 'prize2',
        'wheel_prize3': 'prize3',
        'wheel_lost': 'lost'
      };
      
      const mappedType = typeMap[audioType];
      if (!mappedType) {
        showMessage('Unbekannter Audio-Typ', 'error');
        return;
      }
      
      try {
        const response = await fetch('/api/game-engine/wheel/audio/reset', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ audioType: mappedType, wheelId: DEFAULT_WHEEL_ID })
        });
        
        const data = await response.json();
        if (data.success) {
          showMessage(`Audio "${mappedType}" auf Standard zur√ºckgesetzt`);
          loadWheelMediaSettings();
          // Clear file input
          const inputId = `mediaWheel${mappedType.charAt(0).toUpperCase() + mappedType.slice(1)}`;
          const input = document.getElementById(inputId);
          if (input) input.value = '';
        } else {
          showMessage(`Fehler: ${data.error}`, 'error');
        }
      } catch (error) {
        showMessage(`Fehler: ${error.message}`, 'error');
      }
    }

    // Initialize media game selector on page load
    handleMediaGameSelectorChange();

    // ===========================================
    // Overlay Functions
    // ===========================================
    
    function copyOverlayURL(elementId) {
      const urlInput = document.getElementById(elementId);
      if (!urlInput) return;
      
      const url = urlInput.value;
      navigator.clipboard.writeText(url).then(() => {
        showMessage('‚úÖ Overlay URL in Zwischenablage kopiert!');
      }).catch((err) => {
        console.error('Failed to copy URL:', err);
        showMessage('‚ùå Fehler beim Kopieren der URL', 'error');
      });
    }
    
    function previewOverlay(url) {
      window.open(url, '_blank', 'width=1200,height=800');
    }

    // ===========================================
    // Event Listeners Setup
    // ===========================================
    
    // Column buttons for streamer moves
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('column-button')) {
        const column = e.target.dataset.column;
        if (column) {
          makeStreamerMove(column);
        }
      }
    });
    
    // Cancel game button
    const cancelGameBtn = document.getElementById('cancelGameBtn');
    if (cancelGameBtn) {
      cancelGameBtn.addEventListener('click', cancelGame);
    }
    
    // Save settings button
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    if (saveSettingsBtn) {
      saveSettingsBtn.addEventListener('click', saveSettings);
    }
    
    // Trigger type change
    const triggerTypeSelect = document.getElementById('triggerType');
    if (triggerTypeSelect) {
      triggerTypeSelect.addEventListener('change', updateTriggerInputType);
    }
    
    // Open gift catalog button
    const openGiftCatalogBtn = document.getElementById('openGiftCatalogBtn');
    if (openGiftCatalogBtn) {
      openGiftCatalogBtn.addEventListener('click', openGiftCatalog);
    }
    
    // Refresh gift catalog button
    const refreshGiftCatalogBtn = document.getElementById('refreshGiftCatalogBtn');
    if (refreshGiftCatalogBtn) {
      refreshGiftCatalogBtn.addEventListener('click', refreshGiftCatalog);
    }
    
    // Close gift catalog button
    const closeGiftCatalogBtn = document.getElementById('closeGiftCatalogBtn');
    if (closeGiftCatalogBtn) {
      closeGiftCatalogBtn.addEventListener('click', closeGiftCatalog);
    }
    
    // Add trigger button
    const addTriggerBtn = document.getElementById('addTriggerBtn');
    if (addTriggerBtn) {
      addTriggerBtn.addEventListener('click', addTrigger);
    }
    
    // Save XP rewards button
    const saveXPRewardsBtn = document.getElementById('saveXPRewardsBtn');
    if (saveXPRewardsBtn) {
      saveXPRewardsBtn.addEventListener('click', saveXPRewards);
    }
    
    // Save ELO settings button
    const saveELOSettingsBtn = document.getElementById('saveELOSettingsBtn');
    if (saveELOSettingsBtn) {
      saveELOSettingsBtn.addEventListener('click', saveELOSettings);
    }
    
    // Media upload buttons (event delegation)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('upload-media-btn')) {
        const eventType = e.target.dataset.upload;
        const inputId = e.target.dataset.input;
        if (eventType && inputId) {
          uploadMedia(eventType, inputId);
        }
      }
    });
    
    // Media delete buttons (event delegation)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-media-btn')) {
        const eventType = e.target.dataset.delete;
        if (eventType) {
          deleteMedia(eventType);
        }
      }
    });
    
    // Remove trigger buttons (event delegation)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('remove-trigger-btn')) {
        const triggerId = e.target.dataset.triggerId;
        if (triggerId) {
          removeTrigger(parseInt(triggerId));
        }
      }
    });

    // Overlay copy buttons
    const btnCopyGameboard = document.getElementById('btn-copy-gameboard');
    if (btnCopyGameboard) {
      btnCopyGameboard.addEventListener('click', () => copyOverlayURL('overlay-url-gameboard'));
    }
    
    const btnCopyHud = document.getElementById('btn-copy-hud');
    if (btnCopyHud) {
      btnCopyHud.addEventListener('click', () => copyOverlayURL('overlay-url-hud'));
    }
    
    // New overlay buttons for Chess, Plinko, Wheel
    const btnCopyChessMain = document.getElementById('btn-copy-chess-overlay-main');
    if (btnCopyChessMain) {
      btnCopyChessMain.addEventListener('click', () => copyOverlayURL('overlay-url-chess'));
    }
    
    const btnCopyPlinkoMain = document.getElementById('btn-copy-plinko-overlay-main');
    if (btnCopyPlinkoMain) {
      btnCopyPlinkoMain.addEventListener('click', () => copyOverlayURL('overlay-url-plinko'));
    }
    
    const btnCopyWheelMain = document.getElementById('btn-copy-wheel-overlay-main');
    if (btnCopyWheelMain) {
      btnCopyWheelMain.addEventListener('click', () => copyOverlayURL('overlay-url-wheel'));
    }
    
    // Overlay preview buttons
    const btnPreviewGameboard = document.getElementById('btn-preview-gameboard');
    if (btnPreviewGameboard) {
      btnPreviewGameboard.addEventListener('click', () => {
        previewOverlay(document.getElementById('overlay-url-gameboard').value);
      });
    }
    
    const btnPreviewHud = document.getElementById('btn-preview-hud');
    if (btnPreviewHud) {
      btnPreviewHud.addEventListener('click', () => {
        previewOverlay(document.getElementById('overlay-url-hud').value);
      });
    }
    
    // New preview buttons for Chess, Plinko, Wheel
    const btnPreviewChessMain = document.getElementById('btn-preview-chess-overlay-main');
    if (btnPreviewChessMain) {
      btnPreviewChessMain.addEventListener('click', () => {
        previewOverlay(document.getElementById('overlay-url-chess').value);
      });
    }
    
    const btnPreviewPlinkoMain = document.getElementById('btn-preview-plinko-overlay-main');
    if (btnPreviewPlinkoMain) {
      btnPreviewPlinkoMain.addEventListener('click', () => {
        previewOverlay(document.getElementById('overlay-url-plinko').value);
      });
    }
    
    const btnPreviewWheelMain = document.getElementById('btn-preview-wheel-overlay-main');
    if (btnPreviewWheelMain) {
      btnPreviewWheelMain.addEventListener('click', () => {
        previewOverlay(document.getElementById('overlay-url-wheel').value);
      });
    }

    // ===== MANUAL MODE =====
    
    let manualSessionId = null;
    
    // Start manual game button
    const startManualGameBtn = document.getElementById('start-manual-game');
    if (startManualGameBtn) {
      startManualGameBtn.addEventListener('click', startManualGame);
    }
    
    // End manual game button
    const endManualGameBtn = document.getElementById('end-manual-game');
    if (endManualGameBtn) {
      endManualGameBtn.addEventListener('click', endManualGame);
    }
    
    // Manual move buttons (event delegation)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('manual-move')) {
        const player = parseInt(e.target.dataset.player);
        const column = e.target.dataset.column;
        makeManualMove(player, column);
      }
    });
    
    // Start manual game
    async function startManualGame() {
      const gameType = document.getElementById('manual-game-type').value;
      const opponentType = document.getElementById('manual-opponent-type').value;
      const player1Name = document.getElementById('manual-player1-name').value || 'Test Player 1';
      const player2Name = document.getElementById('manual-player2-name').value || 'Test Player 2';
      
      try {
        const response = await fetch('/api/game-engine/manual/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            gameType,
            opponentType,
            player1Name,
            player2Name
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          manualSessionId = data.sessionId;
          showSuccess(data.message);
          
          // Show manual game controls
          document.getElementById('manual-game-controls').style.display = 'block';
          document.getElementById('manual-session-id').textContent = data.sessionId;
          document.getElementById('manual-game-status').textContent = 'L√§uft';
          
          // Disable start button
          startManualGameBtn.disabled = true;
        } else {
          showError(data.error || data.message || 'Fehler beim Starten des Spiels');
        }
      } catch (error) {
        showError('Fehler beim Starten des Spiels: ' + error.message);
      }
    }
    
    // Make manual move
    async function makeManualMove(player, column) {
      if (!manualSessionId) {
        showError('Kein aktives Test-Spiel');
        return;
      }
      
      try {
        const response = await fetch('/api/game-engine/manual/move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: manualSessionId,
            player,
            column
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          showSuccess(data.message);
          
          // Update current player
          if (data.nextPlayer) {
            document.getElementById('manual-current-player').textContent = 'Spieler ' + data.nextPlayer;
          }
          
          // If game ended, reset
          if (data.result && data.result.gameOver) {
            setTimeout(() => {
              resetManualMode();
            }, 3000);
          }
        } else {
          showError(data.error || 'Fehler beim Ausf√ºhren des Zugs');
        }
      } catch (error) {
        showError('Fehler beim Ausf√ºhren des Zugs: ' + error.message);
      }
    }
    
    // End manual game
    async function endManualGame() {
      if (!manualSessionId) {
        showError('Kein aktives Test-Spiel');
        return;
      }
      
      if (!confirm('M√∂chtest du das Test-Spiel wirklich beenden?')) {
        return;
      }
      
      try {
        const response = await fetch('/api/game-engine/manual/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: manualSessionId
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          showSuccess('Test-Spiel beendet');
          resetManualMode();
        } else {
          showError(data.error || 'Fehler beim Beenden des Spiels');
        }
      } catch (error) {
        showError('Fehler beim Beenden des Spiels: ' + error.message);
      }
    }
    
    // Reset manual mode UI
    function resetManualMode() {
      manualSessionId = null;
      document.getElementById('manual-game-controls').style.display = 'none';
      document.getElementById('manual-session-id').textContent = '-';
      document.getElementById('manual-current-player').textContent = '-';
      document.getElementById('manual-game-status').textContent = 'Beendet';
      startManualGameBtn.disabled = false;
    }

    // Initialize
    loadSettings();
    loadChessSettings();
    loadTriggers();
    loadXPRewards();
    loadStats();
    checkActiveSession();
    loadELOLeaderboard();
    loadCurrentMedia();

    // Chess event listeners
    document.getElementById('saveChessSettingsBtn').addEventListener('click', saveChessSettings);
    document.getElementById('btn-copy-chess-overlay').addEventListener('click', () => {
      const url = document.getElementById('chess-overlay-url').value;
      navigator.clipboard.writeText(url);
      showMessage('Chess Overlay URL kopiert!');
    });
    document.getElementById('btn-preview-chess-overlay').addEventListener('click', () => {
      const url = document.getElementById('chess-overlay-url').value;
      window.open(url, '_blank');
    });
    document.getElementById('chess-sound-volume').addEventListener('input', (e) => {
      const volume = Math.round(e.target.value * 100);
      document.getElementById('chess-volume-display').textContent = volume + '%';
    });

    // === PLINKO FUNCTIONS ===

    let allPlinkoBoards = []; // Array of all plinko boards
    let currentPlinkoBoardId = null; // Currently selected board ID
    let plinkoConfig = null; // Currently selected board config
    let plinkoGiftSelectionMode = false; // Module-scoped state for gift catalog integration

    async function loadAllPlinkoBoards() {
      try {
        const res = await fetch('/api/game-engine/plinko/boards');
        allPlinkoBoards = await res.json();
        
        // Update board selector dropdown
        const selector = document.getElementById('plinko-board-selector');
        selector.innerHTML = '';
        
        allPlinkoBoards.forEach(board => {
          const option = document.createElement('option');
          option.value = board.id;
          option.textContent = `${board.name}${board.enabled ? '' : ' (deaktiviert)'}`;
          selector.appendChild(option);
        });
        
        // Set current board to first board if not set
        if (allPlinkoBoards.length > 0 && !currentPlinkoBoardId) {
          currentPlinkoBoardId = allPlinkoBoards[0].id;
          selector.value = currentPlinkoBoardId;
        }
        
        // Load config for current board
        if (currentPlinkoBoardId) {
          await loadPlinkoBoardConfig(currentPlinkoBoardId);
        }
      } catch (error) {
        console.error('Error loading plinko boards:', error);
        showMessage('Fehler beim Laden der Plinko-Boards', 'error');
      }
    }

    async function loadPlinkoBoardConfig(boardId) {
      try {
        const res = await fetch(`/api/game-engine/plinko/config?boardId=${boardId}`);
        plinkoConfig = await res.json();
        currentPlinkoBoardId = boardId;
        
        // Update board name and settings
        document.getElementById('plinko-board-name').value = plinkoConfig.name || '';
        document.getElementById('plinko-board-chat-command').value = plinkoConfig.chatCommand || '';
        document.getElementById('plinko-board-enabled').checked = plinkoConfig.enabled;
        
        // Load slots
        renderPlinkoSlots();
        
        // Load physics settings
        document.getElementById('plinko-gravity').value = plinkoConfig.physicsSettings.gravity;
        document.getElementById('plinko-ball-restitution').value = plinkoConfig.physicsSettings.ballRestitution;
        document.getElementById('plinko-peg-restitution').value = plinkoConfig.physicsSettings.pegRestitution;
        document.getElementById('plinko-peg-rows').value = plinkoConfig.physicsSettings.pegRows;
        document.getElementById('plinko-peg-spacing').value = plinkoConfig.physicsSettings.pegSpacing;
        document.getElementById('plinko-test-mode').checked = !!plinkoConfig.physicsSettings.testModeEnabled;
        document.getElementById('plinko-max-balls').value = plinkoConfig.physicsSettings.maxSimultaneousBalls || 5;
        
        // Load gift mappings
        renderPlinkoGiftMappings();
      } catch (error) {
        console.error('Error loading plinko board config:', error);
        showMessage('Fehler beim Laden der Board-Konfiguration', 'error');
      }
    }

    async function loadPlinkoConfig() {
      // This is kept for backward compatibility but now uses multi-board system
      await loadAllPlinkoBoards();
    }

    function renderPlinkoSlots() {
      const container = document.getElementById('plinko-slots-container');
      container.innerHTML = '';
      
      plinkoConfig.slots.forEach((slot, index) => {
        const slotDiv = document.createElement('div');
        slotDiv.style.cssText = 'margin-bottom: 15px; padding: 15px; background: #3a3a4e; border-radius: 8px; border-left: 4px solid ' + slot.color;
        
        const osReward = slot.openshockReward || { enabled: false, type: 'Vibrate', intensity: 30, duration: 1000, deviceId: '' };
        
        slotDiv.innerHTML = `
          <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
            <div style="width: 50px; text-align: center; color: #aaa; font-weight: bold;">Slot ${index + 1}</div>
            <div style="flex: 1;">
              <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Multiplikator:</label>
              <input type="number" class="plinko-slot-multiplier" data-index="${index}" value="${slot.multiplier}" min="0" max="100" step="0.1" style="width: 100%;">
            </div>
            <div style="flex: 1;">
              <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Farbe:</label>
              <input type="color" class="plinko-slot-color" data-index="${index}" value="${slot.color}" style="width: 100%;">
            </div>
            <div style="width: 80px; height: 40px; border-radius: 5px; background: ${slot.color}; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; text-shadow: 0 0 3px rgba(0,0,0,0.5);">
              ${slot.multiplier}x
            </div>
          </div>
          
          <!-- OpenShock Reward Configuration -->
          <div style="margin-top: 10px; padding: 10px; background: #2a2a3e; border-radius: 5px; border: 1px solid #4a4a5e;">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px; cursor: pointer;">
              <input type="checkbox" class="plinko-slot-os-enabled" data-index="${index}" ${osReward.enabled ? 'checked' : ''}>
              <span style="color: #00ffff; font-weight: bold;">‚ö° OpenShock Belohnung aktivieren</span>
            </label>
            
            <div class="plinko-slot-os-config" data-index="${index}" style="display: ${osReward.enabled ? 'block' : 'none'}; padding-left: 10px;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 8px;">
                <div>
                  <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 3px;">Typ:</label>
                  <select class="plinko-slot-os-type" data-index="${index}" style="width: 100%;">
                    <option value="Vibrate" ${osReward.type === 'Vibrate' ? 'selected' : ''}>Vibration</option>
                    <option value="Shock" ${osReward.type === 'Shock' ? 'selected' : ''}>Shock</option>
                    <option value="Sound" ${osReward.type === 'Sound' ? 'selected' : ''}>Sound</option>
                  </select>
                </div>
                <div>
                  <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 3px;">Intensit√§t (1-100%):</label>
                  <input type="number" class="plinko-slot-os-intensity" data-index="${index}" value="${osReward.intensity}" min="1" max="100" style="width: 100%;">
                </div>
              </div>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div>
                  <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 3px;">Dauer (ms):</label>
                  <input type="number" class="plinko-slot-os-duration" data-index="${index}" value="${osReward.duration}" min="300" max="5000" step="100" style="width: 100%;">
                </div>
                <div>
                  <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 3px;">Ger√§t ID:</label>
                  <input type="text" class="plinko-slot-os-device" data-index="${index}" value="${osReward.deviceId || ''}" placeholder="Device ID" style="width: 100%;">
                  <small style="color: #888; font-size: 10px;">Aus OpenShock Plugin</small>
                </div>
              </div>
            </div>
          </div>
        `;
        container.appendChild(slotDiv);
        
        // Add toggle listener for OpenShock section
        const checkbox = slotDiv.querySelector('.plinko-slot-os-enabled');
        const configDiv = slotDiv.querySelector('.plinko-slot-os-config');
        checkbox.addEventListener('change', (e) => {
          configDiv.style.display = e.target.checked ? 'block' : 'none';
        });
      });
    }

    function renderPlinkoGiftMappings() {
      const container = document.getElementById('plinko-gift-mappings-container');
      container.innerHTML = '';
      
      const mappings = plinkoConfig.giftMappings || {};
      const keys = Object.keys(mappings);
      
      if (keys.length === 0) {
        container.innerHTML = '<p style="color: #aaa;">Keine Geschenk-Mappings konfiguriert.</p>';
        return;
      }
      
      keys.forEach(giftName => {
        const mapping = mappings[giftName];
        const mappingDiv = document.createElement('div');
        mappingDiv.style.cssText = 'display: flex; gap: 10px; align-items: center; margin-bottom: 10px; padding: 10px; background: #3a3a4e; border-radius: 5px;';
        mappingDiv.innerHTML = `
          <div style="flex: 1;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Geschenk-Name:</label>
            <input type="text" class="plinko-gift-name" data-gift="${giftName}" value="${giftName}" style="width: 100%;">
          </div>
          <div style="flex: 1;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Einsatz (XP):</label>
            <input type="number" class="plinko-gift-bet" data-gift="${giftName}" value="${mapping.betAmount || 100}" min="1" max="10000" style="width: 100%;">
          </div>
          <div style="flex: 1;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Ball-Typ:</label>
            <select class="plinko-gift-ball-type" data-gift="${giftName}" style="width: 100%;">
              <option value="standard" ${mapping.ballType === 'standard' ? 'selected' : ''}>Standard</option>
              <option value="golden" ${mapping.ballType === 'golden' ? 'selected' : ''}>Golden (2x)</option>
            </select>
          </div>
          <button class="danger plinko-remove-gift-mapping" data-gift="${giftName}" style="width: auto; padding: 10px;">üóëÔ∏è</button>
        `;
        container.appendChild(mappingDiv);
      });
    }

    async function savePlinkoSettings() {
      try {
        if (!currentPlinkoBoardId) {
          showMessage('Kein Board ausgew√§hlt', 'error');
          return;
        }
        
        // Collect slots with OpenShock rewards
        const slots = [];
        document.querySelectorAll('.plinko-slot-multiplier').forEach((input, index) => {
          const multiplier = parseFloat(input.value);
          const color = document.querySelector(`.plinko-slot-color[data-index="${index}"]`).value;
          
          // Collect OpenShock reward configuration
          const osEnabled = document.querySelector(`.plinko-slot-os-enabled[data-index="${index}"]`).checked;
          const openshockReward = osEnabled ? {
            enabled: true,
            type: document.querySelector(`.plinko-slot-os-type[data-index="${index}"]`).value,
            intensity: parseInt(document.querySelector(`.plinko-slot-os-intensity[data-index="${index}"]`).value),
            duration: parseInt(document.querySelector(`.plinko-slot-os-duration[data-index="${index}"]`).value),
            deviceId: document.querySelector(`.plinko-slot-os-device[data-index="${index}"]`).value.trim()
          } : {
            enabled: false
          };
          
          slots.push({ multiplier, color, openshockReward });
        });
        
        // Collect physics settings
        const physicsSettings = {
          gravity: parseFloat(document.getElementById('plinko-gravity').value),
          ballRestitution: parseFloat(document.getElementById('plinko-ball-restitution').value),
          pegRestitution: parseFloat(document.getElementById('plinko-peg-restitution').value),
          pegRows: parseInt(document.getElementById('plinko-peg-rows').value),
          pegSpacing: parseInt(document.getElementById('plinko-peg-spacing').value),
          testModeEnabled: document.getElementById('plinko-test-mode').checked,
          maxSimultaneousBalls: parseInt(document.getElementById('plinko-max-balls').value) || 5
        };
        
        // Collect gift mappings
        const giftMappings = {};
        document.querySelectorAll('.plinko-gift-name').forEach(input => {
          const oldName = input.dataset.gift;
          const newName = input.value.trim();
          if (newName) {
            const betAmount = parseInt(document.querySelector(`.plinko-gift-bet[data-gift="${oldName}"]`).value);
            const ballType = document.querySelector(`.plinko-gift-ball-type[data-gift="${oldName}"]`).value;
            giftMappings[newName] = {
              betAmount,
              ballType,
              multiplier: ballType === 'golden' ? 2.0 : 1.0
            };
          }
        });
        
        const res = await fetch('/api/game-engine/plinko/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ boardId: currentPlinkoBoardId, slots, physicsSettings, giftMappings })
        });
        
        if (res.ok) {
          // Count how many slots have OpenShock enabled
          const osEnabledCount = slots.filter(s => s.openshockReward && s.openshockReward.enabled).length;
          const message = osEnabledCount > 0 
            ? `Plinko-Einstellungen gespeichert! ‚ö° ${osEnabledCount} Slot(s) mit OpenShock Belohnungen.`
            : 'Plinko-Einstellungen gespeichert!';
          showMessage(message);
          plinkoConfig = { ...plinkoConfig, slots, physicsSettings, giftMappings };
          renderPlinkoSlots();
          renderPlinkoGiftMappings();
        } else {
          showMessage('Fehler beim Speichern', 'error');
        }
      } catch (error) {
        console.error('Error saving Plinko settings:', error);
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function loadPlinkoStats() {
      try {
        const res = await fetch('/api/game-engine/plinko/stats');
        const stats = await res.json();
        
        document.getElementById('plinko-total-games').textContent = stats.totalGames;
        document.getElementById('plinko-total-bet').textContent = stats.totalBet;
        document.getElementById('plinko-total-payout').textContent = stats.totalPayout;
        document.getElementById('plinko-rtp').textContent = stats.rtp + '%';
        document.getElementById('plinko-avg-multiplier').textContent = stats.avgMultiplier + 'x';
        document.getElementById('plinko-max-win').textContent = stats.maxWin >= 0 ? '+' + stats.maxWin : stats.maxWin;
      } catch (error) {
        console.error('Error loading Plinko stats:', error);
      }
    }

    // Plinko event listeners
    document.getElementById('savePlinkoSettingsBtn').addEventListener('click', savePlinkoSettings);
    document.getElementById('refreshPlinkoStatsBtn').addEventListener('click', loadPlinkoStats);
    
    // Plinko board selector
    document.getElementById('plinko-board-selector')?.addEventListener('change', async (e) => {
      const boardId = parseInt(e.target.value);
      await loadPlinkoBoardConfig(boardId);
    });
    
    // Create new plinko board
    document.getElementById('createPlinkoBoardBtn')?.addEventListener('click', async () => {
      const name = prompt('Name f√ºr das neue Plinko-Board:');
      if (name && name.trim()) {
        try {
          const res = await fetch('/api/game-engine/plinko/boards', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name.trim() })
          });
          const result = await res.json();
          if (result.success) {
            showMessage(`Plinko-Board "${name}" erstellt!`);
            await loadAllPlinkoBoards();
            currentPlinkoBoardId = result.boardId;
            document.getElementById('plinko-board-selector').value = result.boardId;
            await loadPlinkoBoardConfig(result.boardId);
          } else {
            showMessage('Fehler beim Erstellen des Boards', 'error');
          }
        } catch (error) {
          showMessage('Fehler: ' + error.message, 'error');
        }
      }
    });
    
    // Delete plinko board
    document.getElementById('deletePlinkoBoardBtn')?.addEventListener('click', async () => {
      if (!currentPlinkoBoardId) return;
      
      const boardName = plinkoConfig?.name || 'dieses Board';
      if (confirm(`Board "${boardName}" wirklich l√∂schen?`)) {
        try {
          const res = await fetch(`/api/game-engine/plinko/boards/${currentPlinkoBoardId}`, {
            method: 'DELETE'
          });
          const result = await res.json();
          if (result.success) {
            showMessage('Board gel√∂scht');
            await loadAllPlinkoBoards();
          } else {
            showMessage(result.error || 'Fehler beim L√∂schen', 'error');
          }
        } catch (error) {
          showMessage('Fehler: ' + error.message, 'error');
        }
      }
    });
    
    // Update plinko board name
    document.getElementById('updatePlinkoBoardNameBtn')?.addEventListener('click', async () => {
      if (!currentPlinkoBoardId) return;
      
      const name = document.getElementById('plinko-board-name').value.trim();
      if (!name) {
        showMessage('Bitte einen Namen eingeben', 'error');
        return;
      }
      
      try {
        const res = await fetch(`/api/game-engine/plinko/boards/${currentPlinkoBoardId}/name`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        if (res.ok) {
          showMessage('Board-Name aktualisiert');
          await loadAllPlinkoBoards();
        } else {
          showMessage('Fehler beim Aktualisieren', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    });
    
    // Update plinko board chat command
    document.getElementById('updatePlinkoBoardChatCommandBtn')?.addEventListener('click', async () => {
      if (!currentPlinkoBoardId) return;
      
      const chatCommand = document.getElementById('plinko-board-chat-command').value.trim() || null;
      
      try {
        const res = await fetch(`/api/game-engine/plinko/boards/${currentPlinkoBoardId}/chat-command`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ chatCommand })
        });
        if (res.ok) {
          showMessage('Chat-Befehl aktualisiert');
          await loadAllPlinkoBoards();
        } else {
          showMessage('Fehler beim Aktualisieren', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    });
    
    // Update plinko board enabled status
    document.getElementById('plinko-board-enabled')?.addEventListener('change', async (e) => {
      if (!currentPlinkoBoardId) return;
      
      const enabled = e.target.checked;
      try {
        const res = await fetch(`/api/game-engine/plinko/boards/${currentPlinkoBoardId}/enabled`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled })
        });
        if (res.ok) {
          showMessage(`Board ${enabled ? 'aktiviert' : 'deaktiviert'}`);
          await loadAllPlinkoBoards();
        } else {
          showMessage('Fehler beim Aktualisieren', 'error');
          e.target.checked = !enabled; // Revert on error
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
        e.target.checked = !enabled; // Revert on error
      }
    });
    
    // Open plinko gift catalog
    document.getElementById('openPlinkoGiftCatalogBtn')?.addEventListener('click', () => {
      // Reuse the existing gift catalog modal
      openGiftCatalog();
      // Set up handler for plinko gift selection
      plinkoGiftSelectionMode = true;
    });
    
    document.getElementById('addPlinkoSlotBtn').addEventListener('click', () => {
      plinkoConfig.slots.push({ multiplier: 1.0, color: '#4CAF50' });
      renderPlinkoSlots();
    });
    
    document.getElementById('removePlinkoSlotBtn').addEventListener('click', () => {
      if (plinkoConfig.slots.length > 3) {
        plinkoConfig.slots.pop();
        renderPlinkoSlots();
      } else {
        showMessage('Mindestens 3 Slots erforderlich!', 'error');
      }
    });
    
    // Add plinko gift mapping with text input (like wheel pattern)
    document.getElementById('addPlinkoGiftMappingBtn')?.addEventListener('click', async () => {
      if (!currentPlinkoBoardId) {
        showMessage('Kein Plinko-Board ausgew√§hlt', 'error');
        return;
      }
      
      const giftInputEl = document.getElementById('plinko-new-gift-mapping');
      if (!giftInputEl) {
        console.error('plinko-new-gift-mapping element not found');
        return;
      }
      
      const giftInput = giftInputEl.value.trim();
      if (!giftInput) {
        showMessage('Bitte Geschenk-Name oder ID eingeben', 'error');
        return;
      }
      
      if (!plinkoConfig.giftMappings) plinkoConfig.giftMappings = {};
      
      // Save to server first, then update local state
      try {
        const tempMappings = { ...plinkoConfig.giftMappings };
        tempMappings[giftInput] = {
          betAmount: 100,
          ballType: 'standard',
          multiplier: 1.0
        };
        
        const response = await fetch('/api/game-engine/plinko/gift-mappings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ giftMappings: tempMappings, boardId: currentPlinkoBoardId })
        });
        
        if (!response.ok) {
          throw new Error(`Fehler beim Speichern: ${response.status} ${response.statusText}`);
        }
        
        // Only update local state if save was successful
        plinkoConfig.giftMappings = tempMappings;
        giftInputEl.value = '';
        renderPlinkoGiftMappings();
        showMessage(`Geschenk "${giftInput}" hinzugef√ºgt`);
      } catch (error) {
        showMessage('Fehler beim Speichern: ' + error.message, 'error');
      }
    });
    
    // Remove gift mapping (event delegation)
    document.getElementById('plinko-gift-mappings-container').addEventListener('click', (e) => {
      if (e.target.classList.contains('plinko-remove-gift-mapping')) {
        const giftName = e.target.dataset.gift;
        if (confirm(`Geschenk-Mapping "${giftName}" wirklich entfernen?`)) {
          delete plinkoConfig.giftMappings[giftName];
          renderPlinkoGiftMappings();
        }
      }
    });
    
    document.getElementById('btn-copy-plinko-overlay').addEventListener('click', () => {
      const url = document.getElementById('plinko-overlay-url').value;
      navigator.clipboard.writeText(url);
      showMessage('Plinko Overlay URL kopiert!');
    });
    
    document.getElementById('btn-preview-plinko-overlay').addEventListener('click', () => {
      const url = document.getElementById('plinko-overlay-url').value;
      window.open(url, '_blank');
    });
    
    // Handler for plinko gift selection from catalog
    async function handlePlinkoGiftSelection(gift) {
      if (!currentPlinkoBoardId) {
        showMessage('Kein Plinko-Board ausgew√§hlt', 'error');
        plinkoGiftSelectionMode = false;
        closeGiftCatalog();
        return;
      }
      
      if (!plinkoConfig) {
        showMessage('Board-Konfiguration nicht geladen', 'error');
        plinkoGiftSelectionMode = false;
        closeGiftCatalog();
        return;
      }
      
      // Validate gift data
      if (!gift || !gift.id || !gift.name) {
        showMessage('Ung√ºltige Geschenkdaten', 'error');
        return;
      }
      
      if (!plinkoConfig.giftMappings) plinkoConfig.giftMappings = {};
      const giftKey = String(gift.id);
      plinkoConfig.giftMappings[giftKey] = {
        name: gift.name,
        betAmount: 100,
        ballType: 'standard',
        multiplier: 1.0
      };
      
      try {
        const response = await fetch('/api/game-engine/plinko/gift-mappings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ giftMappings: plinkoConfig.giftMappings, boardId: currentPlinkoBoardId })
        });
        
        if (!response.ok) {
          throw new Error('Fehler beim Speichern');
        }
        
        renderPlinkoGiftMappings();
        showMessage(`Geschenk "${gift.name}" zum Plinko-Board "${plinkoConfig.name}" hinzugef√ºgt`);
      } catch (error) {
        showMessage('Fehler beim Speichern: ' + error.message, 'error');
      }
      
      plinkoGiftSelectionMode = false;
      closeGiftCatalog();
    }
    
    // Override click handler on gift grid when in plinko mode
    document.getElementById('gift-grid')?.addEventListener('click', async (e) => {
      // Only process if in plinko mode
      if (!plinkoGiftSelectionMode) return;
      
      const giftCard = e.target.closest('.gift-card');
      if (giftCard) {
        e.stopPropagation();
        e.preventDefault();
        const gift = {
          id: giftCard.dataset.giftId,
          name: giftCard.dataset.giftName
        };
        await handlePlinkoGiftSelection(gift);
      }
    }, true); // Use capture phase to intercept before original handler
    
    // Load Plinko config and stats on page load
    loadPlinkoConfig();
    loadPlinkoStats();

    // === PLINKO TEST MODE FUNCTIONS ===

    // Load boards for test selector
    async function loadTestBoards() {
      try {
        const res = await fetch('/api/game-engine/plinko/boards');
        const boards = await res.json();
        const selector = document.getElementById('test-board-selector');
        selector.innerHTML = '';
        boards.forEach(board => {
          const option = document.createElement('option');
          option.value = board.id;
          option.textContent = board.name;
          selector.appendChild(option);
        });
      } catch (error) {
        console.error('Error loading test boards:', error);
      }
    }

    // Sync slider and input
    const testBetAmount = document.getElementById('test-bet-amount');
    const testBetSlider = document.getElementById('test-bet-slider');
    
    testBetAmount?.addEventListener('input', (e) => {
      const val = Math.min(10000, Math.max(10, parseInt(e.target.value) || 10));
      testBetAmount.value = val;
      if (val <= 1000) {
        testBetSlider.value = val;
      }
    });
    
    testBetSlider?.addEventListener('input', (e) => {
      testBetAmount.value = e.target.value;
    });

    // Spawn single test ball
    document.getElementById('test-spawn-single-btn')?.addEventListener('click', async () => {
      const playerName = document.getElementById('test-player-name')?.value || 'TestUser';
      const betAmount = parseInt(document.getElementById('test-bet-amount')?.value) || 100;
      const count = parseInt(document.getElementById('test-ball-count')?.value) || 1;
      const boardId = parseInt(document.getElementById('test-board-selector')?.value);
      
      try {
        const res = await fetch('/api/game-engine/plinko/test/spawn', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ playerName, betAmount, count, boardId })
        });
        const result = await res.json();
        if (result.success) {
          showMessage(`‚úÖ ${result.count} Test-Ball${result.count > 1 ? 's' : ''} gespawnt f√ºr ${playerName}!`);
          setTimeout(loadTestStats, 500);
        } else {
          showMessage('‚ùå Fehler: ' + result.error, 'error');
        }
      } catch (error) {
        showMessage('‚ùå Fehler: ' + error.message, 'error');
      }
    });

    // Spawn batch with random users
    document.getElementById('test-spawn-batch-btn')?.addEventListener('click', async () => {
      const count = parseInt(document.getElementById('test-ball-count')?.value) || 1;
      const boardId = parseInt(document.getElementById('test-board-selector')?.value);
      
      try {
        for (let i = 0; i < count; i++) {
          const randomBet = Math.floor(Math.random() * 991) + 10; // 10-1000
          const playerName = `TestUser${i + 1}`;
          
          await fetch('/api/game-engine/plinko/test/spawn', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ playerName, betAmount: randomBet, count: 1, boardId })
          });
          
          // Small delay between spawns
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        showMessage(`‚úÖ Batch-Spawn: ${count} B√§lle mit Random-Daten gespawnt!`);
        setTimeout(loadTestStats, 500);
      } catch (error) {
        showMessage('‚ùå Fehler: ' + error.message, 'error');
      }
    });

    // Clear test history
    document.getElementById('test-clear-history-btn')?.addEventListener('click', async () => {
      if (!confirm('Alle Test-Transaktionen l√∂schen?')) return;
      
      try {
        const res = await fetch('/api/game-engine/plinko/test/history', { method: 'DELETE' });
        const result = await res.json();
        if (result.success) {
          showMessage(`‚úÖ ${result.deletedCount} Test-Eintr√§ge gel√∂scht!`);
          loadTestStats();
          loadTestHistory();
        }
      } catch (error) {
        showMessage('‚ùå Fehler: ' + error.message, 'error');
      }
    });

    // Preset buttons
    document.querySelectorAll('.test-preset').forEach(btn => {
      btn.addEventListener('click', () => {
        const bet = parseInt(btn.dataset.bet);
        const count = parseInt(btn.dataset.count);
        document.getElementById('test-bet-amount').value = bet;
        document.getElementById('test-bet-slider').value = Math.min(1000, bet);
        document.getElementById('test-ball-count').value = count;
        // Auto-trigger spawn
        document.getElementById('test-spawn-single-btn').click();
      });
    });

    // Refresh stats
    document.getElementById('test-refresh-stats-btn')?.addEventListener('click', () => {
      loadTestStats();
      loadTestHistory();
    });

    // Load test stats
    async function loadTestStats() {
      try {
        const res = await fetch('/api/game-engine/plinko/test/stats');
        const stats = await res.json();
        
        document.getElementById('test-total-spawns').textContent = stats.totalGames || 0;
        document.getElementById('test-total-bet').textContent = `${stats.totalBet || 0} XP`;
        document.getElementById('test-avg-multiplier').textContent = `${(stats.avgMultiplier || 0).toFixed(2)}x`;
        document.getElementById('test-rtp').textContent = `${(stats.rtp || 0).toFixed(1)}%`;
      } catch (error) {
        console.error('Error loading test stats:', error);
      }
    }

    // Load test history
    async function loadTestHistory() {
      try {
        const res = await fetch('/api/game-engine/plinko/test/history?limit=50');
        const history = await res.json();
        
        const tbody = document.getElementById('test-history-tbody');
        tbody.innerHTML = '';
        
        history.forEach(tx => {
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid rgba(100, 181, 246, 0.1)';
          
          const time = new Date(tx.timestamp).toLocaleTimeString('de-DE');
          const profit = tx.profit;
          const profitColor = profit >= 0 ? '#4CAF50' : '#f44336';
          const profitSign = profit >= 0 ? '+' : '';
          
          row.innerHTML = `
            <td style="padding: 10px;">${time}</td>
            <td style="padding: 10px;">${tx.user}</td>
            <td style="padding: 10px; text-align: right;">${tx.bet} XP</td>
            <td style="padding: 10px; text-align: right;">${tx.multiplier.toFixed(2)}x</td>
            <td style="padding: 10px; text-align: right; color: ${profitColor}; font-weight: bold;">${profitSign}${profit} XP</td>
          `;
          tbody.appendChild(row);
        });
        
        if (history.length === 0) {
          tbody.innerHTML = '<tr><td colspan="5" style="padding: 20px; text-align: center; color: #888;">Noch keine Test-Drops</td></tr>';
        }
      } catch (error) {
        console.error('Error loading test history:', error);
      }
    }

    // Initialize test mode
    loadTestBoards();
    loadTestStats();
    loadTestHistory();

    // === WHEEL (GL√úCKSRAD) FUNCTIONS - MULTI-WHEEL SUPPORT ===

    let allWheels = []; // Array of all wheels
    let currentWheelId = null; // Currently selected wheel ID
    let wheelConfig = null; // Currently selected wheel config
    let wheelGiftSelectionMode = false; // Module-scoped state for gift catalog integration

    async function loadAllWheels() {
      try {
        const res = await fetch('/api/game-engine/wheels');
        allWheels = await res.json();
        
        // Populate wheel selector
        const selector = document.getElementById('wheel-selector');
        selector.innerHTML = '';
        
        allWheels.forEach(wheel => {
          const option = document.createElement('option');
          option.value = wheel.id;
          option.textContent = `${wheel.name} (ID: ${wheel.id})${!wheel.enabled ? ' [Deaktiviert]' : ''}`;
          selector.appendChild(option);
        });
        
        // Select first wheel if none selected or current doesn't exist
        if (!currentWheelId || !allWheels.find(w => w.id === currentWheelId)) {
          currentWheelId = allWheels.length > 0 ? allWheels[0].id : null;
        }
        
        if (currentWheelId) {
          selector.value = currentWheelId;
          await loadWheelConfig(currentWheelId);
        }
      } catch (error) {
        console.error('Error loading wheels:', error);
        showMessage('Fehler beim Laden der Wheels', 'error');
      }
    }

    async function loadWheelConfig(wheelId = null) {
      try {
        const targetWheelId = wheelId || currentWheelId;
        if (!targetWheelId) return;
        
        const res = await fetch(`/api/game-engine/wheel/config?wheelId=${targetWheelId}`);
        wheelConfig = await res.json();
        
        if (!wheelConfig) {
          showMessage('Wheel nicht gefunden', 'error');
          return;
        }
        
        currentWheelId = wheelConfig.id;
        
        // Update wheel name display
        document.getElementById('current-wheel-name').textContent = wheelConfig.name || 'Unnamed Wheel';
        
        // Load name and enabled status
        document.getElementById('wheel-name-input').value = wheelConfig.name || '';
        document.getElementById('wheel-enabled').checked = wheelConfig.enabled !== false;
        
        // Load chat command
        document.getElementById('wheel-chat-command').value = wheelConfig.chatCommand || '';
        
        // Load segments
        renderWheelSegments();
        
        // Load settings
        const settings = wheelConfig.settings || {};
        document.getElementById('wheel-spin-duration').value = settings.spinDuration || 5000;
        document.getElementById('wheel-winner-display-duration').value = settings.winnerDisplayDuration || 5;
        document.getElementById('wheel-sound-enabled').checked = settings.soundEnabled !== false;
        document.getElementById('wheel-sound-volume').value = settings.soundVolume || 0.7;
        document.getElementById('wheel-volume-display').textContent = Math.round((settings.soundVolume || 0.7) * 100) + '%';
        document.getElementById('wheel-show-queue').checked = settings.showQueue !== false;
        
        // Load Niete settings
        document.getElementById('wheel-niete-text').value = settings.nieteText || 'Leider kein Gewinn!';
        
        // Load Idle Message settings
        document.getElementById('wheel-idle-message-enabled').checked = settings.idleMessageEnabled !== false;
        document.getElementById('wheel-idle-message-title').value = settings.idleMessageTitle || 'üé° Warte auf Spieler...';
        document.getElementById('wheel-idle-message-subtitle').value = settings.idleMessageSubtitle || 'Sende ein Geschenk, um das Gl√ºcksrad zu drehen!';
        
        // Load Info Screen settings
        document.getElementById('wheel-info-screen-enabled').checked = settings.infoScreenEnabled || false;
        document.getElementById('wheel-info-screen-text').value = settings.infoScreenText || 'Um deinen Gewinn abzuholen, besuche discord.gg/deinserver';
        document.getElementById('wheel-info-screen-duration').value = settings.infoScreenDuration || 5;
        
        // Load gift triggers
        renderWheelGiftTriggers();
        
        // Load custom audio settings
        loadWheelAudioSettings();
      } catch (error) {
        console.error('Error loading Wheel config:', error);
        showMessage('Fehler beim Laden der Wheel-Konfiguration', 'error');
      }
    }

    async function createNewWheel() {
      const name = prompt('Name f√ºr das neue Wheel:', 'Neues Wheel');
      if (!name) return;
      
      try {
        const res = await fetch('/api/game-engine/wheels', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        
        const data = await res.json();
        
        if (data.success) {
          showMessage(`Wheel "${name}" erstellt!`);
          currentWheelId = data.wheelId;
          await loadAllWheels();
        } else {
          showMessage('Fehler beim Erstellen des Wheels', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function deleteCurrentWheel() {
      if (!currentWheelId) return;
      
      if (allWheels.length <= 1) {
        showMessage('Das letzte Wheel kann nicht gel√∂scht werden!', 'error');
        return;
      }
      
      const wheel = allWheels.find(w => w.id === currentWheelId);
      if (!confirm(`Wheel "${wheel?.name || 'Unnamed'}" wirklich l√∂schen?\n\nAlle Trigger f√ºr dieses Wheel gehen verloren!`)) {
        return;
      }
      
      try {
        const res = await fetch(`/api/game-engine/wheels/${currentWheelId}`, {
          method: 'DELETE'
        });
        
        const data = await res.json();
        
        if (data.success) {
          showMessage('Wheel gel√∂scht!');
          currentWheelId = null;
          await loadAllWheels();
        } else {
          showMessage(data.error || 'Fehler beim L√∂schen', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    function renderWheelSegments() {
      const container = document.getElementById('wheel-segments-container');
      container.innerHTML = '';
      
      if (!wheelConfig || !wheelConfig.segments) return;
      
      wheelConfig.segments.forEach((segment, index) => {
        const segmentDiv = document.createElement('div');
        segmentDiv.className = 'wheel-segment-item';
        segmentDiv.draggable = true;
        segmentDiv.dataset.index = index;
        segmentDiv.style.cssText = 'display: flex; gap: 10px; align-items: center; margin-bottom: 10px; padding: 10px; background: #3a3a4e; border-radius: 5px; cursor: move; transition: all 0.2s; flex-wrap: wrap;';
        segmentDiv.innerHTML = `
          <div style="width: 30px; text-align: center; color: #888; cursor: grab; user-select: none;" class="drag-handle" title="Ziehen zum Verschieben">
            ‚ãÆ‚ãÆ
          </div>
          <div style="width: 40px; text-align: center; color: #aaa; font-weight: bold;">
            #${index + 1}
          </div>
          <div style="flex: 2; min-width: 120px;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Text (Preis):</label>
            <input type="text" class="wheel-segment-text" data-index="${index}" value="${segment.text || ''}" placeholder="z.B. Shoutout!" style="width: 100%;">
          </div>
          <div style="width: 80px;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">XP Bonus:</label>
            <input type="number" class="wheel-segment-xp" data-index="${index}" value="${segment.xpReward || 0}" min="0" max="100000" step="10" style="width: 100%;" placeholder="0" title="XP die automatisch vergeben werden">
          </div>
          <div style="flex: 1; min-width: 60px;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Farbe:</label>
            <input type="color" class="wheel-segment-color" data-index="${index}" value="${segment.color || '#4CAF50'}" style="width: 100%; height: 35px; cursor: pointer;">
          </div>
          <div style="width: 70px;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Gewicht:</label>
            <input type="number" class="wheel-segment-weight" data-index="${index}" value="${segment.weight || 1}" min="1" max="100" style="width: 100%;">
          </div>
          <div style="width: 80px;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">üîä Audio:</label>
            <select class="wheel-segment-audio" data-index="${index}" style="width: 100%; padding: 5px; background: #1a1a2e; border: 1px solid #444; border-radius: 5px; color: #eee;" title="Gewinn-Audio f√ºr dieses Segment">
              <option value="1" ${Number(segment.prizeAudio || 1) === 1 ? 'selected' : ''}>Preis 1</option>
              <option value="2" ${Number(segment.prizeAudio || 1) === 2 ? 'selected' : ''}>Preis 2</option>
              <option value="3" ${Number(segment.prizeAudio || 1) === 3 ? 'selected' : ''}>Preis 3</option>
            </select>
          </div>
          <div style="width: 60px; text-align: center;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Niete:</label>
            <input type="checkbox" class="wheel-segment-niete" data-index="${index}" ${segment.isNiete ? 'checked' : ''} style="width: 20px; height: 20px; cursor: pointer;" title="Als Niete (kein Gewinn) markieren">
          </div>
          <div style="width: 60px; text-align: center;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">‚ö° Shock:</label>
            <input type="checkbox" class="wheel-segment-shock" data-index="${index}" ${segment.isShock ? 'checked' : ''} style="width: 20px; height: 20px; cursor: pointer;" title="Shock via OpenShock ausl√∂sen" aria-label="Shock aktivieren f√ºr Segment ${index + 1}">
          </div>
          <div style="width: 80px;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Intensit√§t:</label>
            <input type="number" class="wheel-segment-shock-intensity" data-index="${index}" value="${segment.shockIntensity || 50}" min="1" max="100" style="width: 100%;" placeholder="50" title="Shock-Intensit√§t (1-100)" aria-label="Shock-Intensit√§t f√ºr Segment ${index + 1}" ${!segment.isShock ? 'disabled' : ''}>
          </div>
          <div style="width: 80px;">
            <label style="display: block; font-size: 12px; color: #aaa; margin-bottom: 3px;">Dauer (ms):</label>
            <input type="number" class="wheel-segment-shock-duration" data-index="${index}" value="${segment.shockDuration || 1000}" min="300" max="30000" step="100" style="width: 100%;" placeholder="1000" title="Shock-Dauer in Millisekunden (300-30000)" aria-label="Shock-Dauer f√ºr Segment ${index + 1}" ${!segment.isShock ? 'disabled' : ''}>
          </div>
          <div style="width: 80px; height: 40px; border-radius: 5px; background: ${segment.color || '#4CAF50'}; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; text-shadow: 0 0 3px rgba(0,0,0,0.5); font-size: 10px; text-align: center; padding: 2px; overflow: hidden; ${segment.isNiete ? 'opacity: 0.6;' : ''}">
            ${segment.isShock ? '‚ö°' : (segment.isNiete ? 'üò¢' : (segment.xpReward > 0 ? `‚≠ê${segment.xpReward}` : ''))}${segment.isShock ? (segment.shockIntensity || 50) : (segment.xpReward > 0 ? '' : (segment.text || 'Preis').substring(0, 8))}
          </div>
          <div style="display: flex; gap: 5px; flex-direction: column;">
            <button class="wheel-segment-copy" data-index="${index}" style="padding: 5px 10px; background: #4CAF50; border: none; border-radius: 3px; color: white; cursor: pointer; font-size: 12px;" title="Segment kopieren">
              üìã
            </button>
            <button class="wheel-segment-delete" data-index="${index}" style="padding: 5px 10px; background: #f44336; border: none; border-radius: 3px; color: white; cursor: pointer; font-size: 12px;" title="Segment l√∂schen">
              üóëÔ∏è
            </button>
          </div>
        `;
        
        // Add drag and drop event listeners
        segmentDiv.addEventListener('dragstart', handleDragStart);
        segmentDiv.addEventListener('dragover', handleDragOver);
        segmentDiv.addEventListener('drop', handleDrop);
        segmentDiv.addEventListener('dragend', handleDragEnd);
        segmentDiv.addEventListener('dragenter', handleDragEnter);
        segmentDiv.addEventListener('dragleave', handleDragLeave);
        
        container.appendChild(segmentDiv);
      });
    }
    
    // Use event delegation for copy and delete buttons on the container
    document.getElementById('wheel-segments-container').addEventListener('click', (e) => {
      if (e.target.classList.contains('wheel-segment-copy')) {
        const index = parseInt(e.target.dataset.index);
        copyWheelSegment(index);
      } else if (e.target.classList.contains('wheel-segment-delete')) {
        const index = parseInt(e.target.dataset.index);
        deleteWheelSegment(index);
      }
    });
    
    // Use event delegation for shock checkbox change
    document.getElementById('wheel-segments-container').addEventListener('change', (e) => {
      if (e.target.classList.contains('wheel-segment-shock')) {
        const index = parseInt(e.target.dataset.index);
        const isChecked = e.target.checked;
        const intensityInput = document.querySelector(`.wheel-segment-shock-intensity[data-index="${index}"]`);
        const durationInput = document.querySelector(`.wheel-segment-shock-duration[data-index="${index}"]`);
        
        if (intensityInput) intensityInput.disabled = !isChecked;
        if (durationInput) durationInput.disabled = !isChecked;
      }
    });
    
    // Drag and Drop Variables
    let draggedSegmentIndex = null;
    
    function handleDragStart(e) {
      draggedSegmentIndex = parseInt(e.currentTarget.dataset.index);
      e.currentTarget.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', e.currentTarget.innerHTML);
    }
    
    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }
    
    function handleDragEnter(e) {
      if (e.currentTarget.classList.contains('wheel-segment-item')) {
        e.currentTarget.style.borderTop = '3px solid #4CAF50';
      }
    }
    
    function handleDragLeave(e) {
      if (e.currentTarget.classList.contains('wheel-segment-item')) {
        e.currentTarget.style.borderTop = '';
      }
    }
    
    function handleDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      e.preventDefault();
      
      const targetIndex = parseInt(e.currentTarget.dataset.index);
      
      if (draggedSegmentIndex !== null && draggedSegmentIndex !== targetIndex) {
        // Move the segment
        const segments = wheelConfig.segments;
        const draggedSegment = segments[draggedSegmentIndex];
        
        // Remove from old position
        segments.splice(draggedSegmentIndex, 1);
        
        // Insert at new position
        // If dragging down (from lower index to higher), we need to subtract 1
        // because the array shifted after removing the element
        const newIndex = draggedSegmentIndex < targetIndex ? targetIndex - 1 : targetIndex;
        segments.splice(newIndex, 0, draggedSegment);
        
        // Re-render
        renderWheelSegments();
        showMessage('Segment verschoben');
      }
      
      return false;
    }
    
    function handleDragEnd(e) {
      e.currentTarget.style.opacity = '1';
      
      // Remove all drag styling
      document.querySelectorAll('.wheel-segment-item').forEach(item => {
        item.style.borderTop = '';
      });
      
      draggedSegmentIndex = null;
    }
    
    function copyWheelSegment(index) {
      if (!wheelConfig.segments || index < 0 || index >= wheelConfig.segments.length) return;
      
      const segmentToCopy = wheelConfig.segments[index];
      const copiedSegment = {
        text: segmentToCopy.text + ' (Kopie)',
        color: segmentToCopy.color,
        weight: segmentToCopy.weight,
        isNiete: segmentToCopy.isNiete || false,
        xpReward: segmentToCopy.xpReward || 0,
        prizeAudio: segmentToCopy.prizeAudio || 1,
        isShock: segmentToCopy.isShock || false,
        shockIntensity: segmentToCopy.shockIntensity || 50,
        shockDuration: segmentToCopy.shockDuration || 1000
      };
      
      // Insert after the current segment
      wheelConfig.segments.splice(index + 1, 0, copiedSegment);
      renderWheelSegments();
      showMessage('Segment kopiert');
    }
    
    function deleteWheelSegment(index) {
      if (!wheelConfig.segments || wheelConfig.segments.length <= 2) {
        showMessage('Mindestens 2 Segmente erforderlich!', 'error');
        return;
      }
      
      if (index < 0 || index >= wheelConfig.segments.length) return;
      
      const segmentText = wheelConfig.segments[index].text || `Segment ${index + 1}`;
      
      if (confirm(`Segment "${segmentText}" wirklich l√∂schen?`)) {
        wheelConfig.segments.splice(index, 1);
        renderWheelSegments();
        showMessage('Segment gel√∂scht');
      }
    }

    function renderWheelGiftTriggers() {
      const container = document.getElementById('wheel-gift-triggers-container');
      container.innerHTML = '';
      
      const triggers = wheelConfig?.giftTriggers || {};
      const keys = Object.keys(triggers);
      
      if (keys.length === 0) {
        container.innerHTML = '<p style="color: #aaa;">Keine Geschenk-Trigger konfiguriert. F√ºge Geschenke hinzu, um dieses Wheel zu aktivieren.</p>';
        return;
      }
      
      keys.forEach(giftKey => {
        const triggerDiv = document.createElement('div');
        triggerDiv.style.cssText = 'display: flex; gap: 10px; align-items: center; margin-bottom: 10px; padding: 10px; background: #3a3a4e; border-radius: 5px;';
        triggerDiv.innerHTML = `
          <div style="flex: 1;">
            <span style="color: #FFD700;">üéÅ</span> ${giftKey}
          </div>
          <button class="danger wheel-remove-gift-trigger" data-gift="${giftKey}" style="width: auto; padding: 8px 12px;">üóëÔ∏è Entfernen</button>
        `;
        container.appendChild(triggerDiv);
      });
    }

    async function saveWheelSettings() {
      if (!currentWheelId) {
        showMessage('Kein Wheel ausgew√§hlt', 'error');
        return;
      }
      
      try {
        // Update wheel name
        const newName = document.getElementById('wheel-name-input').value.trim();
        if (newName && newName !== wheelConfig.name) {
          await fetch(`/api/game-engine/wheels/${currentWheelId}/name`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: newName })
          });
        }
        
        // Update enabled status
        const enabled = document.getElementById('wheel-enabled').checked;
        await fetch(`/api/game-engine/wheels/${currentWheelId}/enabled`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled })
        });
        
        // Update chat command
        const chatCommand = document.getElementById('wheel-chat-command').value.trim();
        await fetch(`/api/game-engine/wheels/${currentWheelId}/chat-command`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ chatCommand: chatCommand || null })
        });
        
        // Collect segments
        const segments = [];
        document.querySelectorAll('.wheel-segment-text').forEach((input, index) => {
          const text = input.value.trim() || `Preis ${index + 1}`;
          const color = document.querySelector(`.wheel-segment-color[data-index="${index}"]`).value;
          const weight = parseInt(document.querySelector(`.wheel-segment-weight[data-index="${index}"]`).value) || 1;
          const isNiete = document.querySelector(`.wheel-segment-niete[data-index="${index}"]`)?.checked || false;
          const xpReward = parseInt(document.querySelector(`.wheel-segment-xp[data-index="${index}"]`)?.value) || 0;
          const prizeAudio = parseInt(document.querySelector(`.wheel-segment-audio[data-index="${index}"]`)?.value) || 1;
          const isShock = document.querySelector(`.wheel-segment-shock[data-index="${index}"]`)?.checked || false;
          const shockIntensity = parseInt(document.querySelector(`.wheel-segment-shock-intensity[data-index="${index}"]`)?.value) || 50;
          const shockDuration = parseInt(document.querySelector(`.wheel-segment-shock-duration[data-index="${index}"]`)?.value) || 1000;
          segments.push({ text, color, weight, isNiete, xpReward, prizeAudio, isShock, shockIntensity, shockDuration });
        });
        
        // Collect settings
        const settings = {
          spinDuration: parseInt(document.getElementById('wheel-spin-duration').value) || 5000,
          winnerDisplayDuration: parseInt(document.getElementById('wheel-winner-display-duration').value) || 5,
          soundEnabled: document.getElementById('wheel-sound-enabled').checked,
          soundVolume: parseFloat(document.getElementById('wheel-sound-volume').value) || 0.7,
          showQueue: document.getElementById('wheel-show-queue').checked,
          // Niete settings
          nieteText: document.getElementById('wheel-niete-text').value || 'Leider kein Gewinn!',
          // Idle Message settings
          idleMessageEnabled: document.getElementById('wheel-idle-message-enabled').checked,
          idleMessageTitle: document.getElementById('wheel-idle-message-title').value || 'üé° Warte auf Spieler...',
          idleMessageSubtitle: document.getElementById('wheel-idle-message-subtitle').value || 'Sende ein Geschenk, um das Gl√ºcksrad zu drehen!',
          // Info Screen settings
          infoScreenEnabled: document.getElementById('wheel-info-screen-enabled').checked,
          infoScreenText: document.getElementById('wheel-info-screen-text').value || 'Um deinen Gewinn abzuholen, besuche discord.gg/deinserver',
          infoScreenDuration: parseInt(document.getElementById('wheel-info-screen-duration').value) || 5
        };
        
        const res = await fetch('/api/game-engine/wheel/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ wheelId: currentWheelId, segments, settings })
        });
        
        if (res.ok) {
          showMessage('Wheel-Einstellungen gespeichert!');
          wheelConfig.segments = segments;
          wheelConfig.settings = settings;
          wheelConfig.name = newName || wheelConfig.name;
          wheelConfig.enabled = enabled;
          wheelConfig.chatCommand = chatCommand || null;
          
          document.getElementById('current-wheel-name').textContent = wheelConfig.name;
          renderWheelSegments();
          await loadAllWheels(); // Refresh selector
        } else {
          showMessage('Fehler beim Speichern', 'error');
        }
      } catch (error) {
        console.error('Error saving Wheel settings:', error);
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function loadWheelStats() {
      try {
        const res = await fetch('/api/game-engine/wheel/stats');
        const stats = await res.json();
        
        document.getElementById('wheel-total-spins').textContent = stats.totalSpins || 0;
        document.getElementById('wheel-unique-players').textContent = stats.uniquePlayers || 0;
        document.getElementById('wheel-prizes-paid').textContent = stats.prizesPaid || 0;
        document.getElementById('wheel-prizes-pending').textContent = stats.prizesPending || 0;
        
        // Popular prizes
        const popularContainer = document.getElementById('wheel-popular-prizes');
        if (stats.popularPrizes && stats.popularPrizes.length > 0) {
          popularContainer.innerHTML = stats.popularPrizes.map((p, i) => 
            `<span style="margin-right: 15px;">${i + 1}. ${p.prize_text} (${p.count}x)</span>`
          ).join('');
        } else {
          popularContainer.innerHTML = '<span style="color: #666;">Noch keine Daten</span>';
        }
      } catch (error) {
        console.error('Error loading Wheel stats:', error);
      }
    }

    async function loadWheelWinsLog(onlyUnpaid = false) {
      try {
        const endpoint = onlyUnpaid ? '/api/game-engine/wheel/unpaid' : '/api/game-engine/wheel/history';
        const res = await fetch(endpoint);
        const wins = await res.json();
        
        const tbody = document.getElementById('wheel-wins-table-body');
        
        if (!wins || wins.length === 0) {
          tbody.innerHTML = '<tr><td colspan="6" style="padding: 20px; text-align: center; color: #666;">Keine Gewinne gefunden</td></tr>';
          return;
        }
        
        tbody.innerHTML = wins.map(win => `
          <tr style="background: ${win.paid_out ? '#2a3a2e' : '#3a2a2e'};" data-win-id="${win.id}">
            <td style="padding: 8px;">${new Date(win.timestamp).toLocaleString('de-DE')}</td>
            <td>${win.nickname || win.username}</td>
            <td style="color: #FFD700; font-weight: bold;">${win.prize_text}</td>
            <td>${win.gift_name || '-'}${win.wheel_name ? ` <small style="color: #888;">(${win.wheel_name})</small>` : ''}</td>
            <td style="text-align: center;">
              ${win.paid_out 
                ? '<span style="color: #4CAF50;">‚úÖ Ausgezahlt</span>' 
                : '<span style="color: #FFC107;">‚è≥ Ausstehend</span>'}
            </td>
            <td style="text-align: center;">
              <div style="display: flex; gap: 5px; justify-content: center; flex-wrap: wrap;">
                ${!win.paid_out 
                  ? `<button class="wheel-pay-btn secondary" data-win-id="${win.id}" style="padding: 5px 8px; font-size: 11px;">üí∞ Auszahlen</button>`
                  : ''}
                <button class="wheel-edit-btn secondary" data-win-id="${win.id}" data-prize="${encodeURIComponent(win.prize_text)}" style="padding: 5px 8px; font-size: 11px; background: #2196F3;">‚úèÔ∏è</button>
                <button class="wheel-delete-btn danger" data-win-id="${win.id}" style="padding: 5px 8px; font-size: 11px;">üóëÔ∏è</button>
              </div>
            </td>
          </tr>
        `).join('');
      } catch (error) {
        console.error('Error loading Wheel wins:', error);
      }
    }

    async function editWheelWin(winId, currentPrize) {
      const newPrize = prompt('Neuen Gewinntext eingeben:', decodeURIComponent(currentPrize));
      if (newPrize === null || newPrize.trim() === '') return;
      
      try {
        const res = await fetch(`/api/game-engine/wheel/win/${winId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prize_text: newPrize.trim() })
        });
        
        if (res.ok) {
          showMessage('Gewinn aktualisiert!');
          loadWheelWinsLog();
          loadWheelStats();
        } else {
          showMessage('Fehler beim Aktualisieren', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function deleteWheelWin(winId) {
      if (!confirm('Diesen Gewinn wirklich l√∂schen?')) return;
      
      try {
        const res = await fetch(`/api/game-engine/wheel/win/${winId}`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          showMessage('Gewinn gel√∂scht!');
          loadWheelWinsLog();
          loadWheelStats();
        } else {
          showMessage('Fehler beim L√∂schen', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function resetAllWheelWins() {
      if (!confirm('‚ö†Ô∏è ACHTUNG: Alle Gewinne werden unwiderruflich gel√∂scht!\n\nBist du sicher?')) return;
      if (!confirm('üî¥ LETZTE WARNUNG: Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!\n\nWirklich ALLE Gewinne l√∂schen?')) return;
      
      try {
        const res = await fetch('/api/game-engine/wheel/reset-wins', {
          method: 'DELETE'
        });
        
        if (res.ok) {
          showMessage('Alle Gewinne wurden gel√∂scht!');
          loadWheelWinsLog();
          loadWheelStats();
        } else {
          showMessage('Fehler beim Zur√ºcksetzen', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function markPrizeAsPaid(winId) {
      try {
        const res = await fetch(`/api/game-engine/wheel/pay/${winId}`, {
          method: 'POST'
        });
        
        if (res.ok) {
          showMessage('Gewinn als ausgezahlt markiert!');
          loadWheelWinsLog();
          loadWheelStats();
        } else {
          showMessage('Fehler beim Markieren', 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    async function triggerTestSpin() {
      if (!currentWheelId) {
        showMessage('Kein Wheel ausgew√§hlt', 'error');
        return;
      }
      
      try {
        const playerName = document.getElementById('wheel-test-player').value || 'TestSpieler';
        
        const res = await fetch('/api/game-engine/wheel/spin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            username: playerName.toLowerCase().replace(/\s+/g, '_'),
            nickname: playerName,
            giftName: 'Test-Spin',
            wheelId: currentWheelId
          })
        });
        
        const result = await res.json();
        
        if (result.success) {
          if (result.queued) {
            showMessage(`Test-Spin f√ºr ${playerName} in Warteschlange (Position ${result.position})`);
          } else {
            showMessage(`Test-Spin f√ºr ${playerName} auf "${wheelConfig?.name || 'Wheel'}" gestartet!`);
          }
        } else {
          showMessage('Fehler: ' + (result.error || 'Unbekannter Fehler'), 'error');
        }
      } catch (error) {
        showMessage('Fehler: ' + error.message, 'error');
      }
    }

    // Wheel event listeners
    const wheelSelector = document.getElementById('wheel-selector');
    if (wheelSelector) {
      wheelSelector.addEventListener('change', (e) => {
        currentWheelId = parseInt(e.target.value);
        loadWheelConfig(currentWheelId);
      });
    }
    
    const createNewWheelBtn = document.getElementById('createNewWheelBtn');
    if (createNewWheelBtn) {
      createNewWheelBtn.addEventListener('click', createNewWheel);
    }
    
    const deleteCurrentWheelBtn = document.getElementById('deleteCurrentWheelBtn');
    if (deleteCurrentWheelBtn) {
      deleteCurrentWheelBtn.addEventListener('click', deleteCurrentWheel);
    }
    
    const saveWheelSettingsBtn = document.getElementById('saveWheelSettingsBtn');
    if (saveWheelSettingsBtn) {
      saveWheelSettingsBtn.addEventListener('click', saveWheelSettings);
    } else {
      console.error('saveWheelSettingsBtn element not found!');
    }
    
    const refreshWheelStatsBtn = document.getElementById('refreshWheelStatsBtn');
    if (refreshWheelStatsBtn) {
      refreshWheelStatsBtn.addEventListener('click', () => {
        loadWheelStats();
        showMessage('Statistiken aktualisiert');
      });
    }
    
    const addWheelSegmentBtn = document.getElementById('addWheelSegmentBtn');
    if (addWheelSegmentBtn) {
      addWheelSegmentBtn.addEventListener('click', () => {
        if (!wheelConfig.segments) wheelConfig.segments = [];
        wheelConfig.segments.push({ text: 'Neuer Preis', color: '#4CAF50', weight: 5, isNiete: false, xpReward: 0, prizeAudio: 1, isShock: false, shockIntensity: 50, shockDuration: 1000 });
        renderWheelSegments();
      });
    }
    
    const addWheelGiftTriggerBtn = document.getElementById('addWheelGiftTriggerBtn');
    if (addWheelGiftTriggerBtn) {
      addWheelGiftTriggerBtn.addEventListener('click', async () => {
        if (!currentWheelId) {
          showMessage('Kein Wheel ausgew√§hlt', 'error');
          return;
        }
        
        const giftInputEl = document.getElementById('wheel-new-gift-trigger');
        if (!giftInputEl) {
          console.error('wheel-new-gift-trigger element not found');
          return;
        }
        
        const giftInput = giftInputEl.value.trim();
        if (!giftInput) {
          showMessage('Bitte Geschenk-Name oder ID eingeben', 'error');
          return;
        }
        
        if (!wheelConfig.giftTriggers) wheelConfig.giftTriggers = {};
        wheelConfig.giftTriggers[giftInput] = { enabled: true };
        
        // Save to server
        try {
          await fetch('/api/game-engine/wheel/gift-triggers', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ giftTriggers: wheelConfig.giftTriggers, wheelId: currentWheelId })
          });
          
          giftInputEl.value = '';
          renderWheelGiftTriggers();
          showMessage(`Geschenk "${giftInput}" hinzugef√ºgt`);
        } catch (error) {
          showMessage('Fehler beim Speichern', 'error');
        }
      });
    }
    
    const openWheelGiftCatalogBtn = document.getElementById('openWheelGiftCatalogBtn');
    if (openWheelGiftCatalogBtn) {
      openWheelGiftCatalogBtn.addEventListener('click', () => {
        // Reuse the existing gift catalog modal
        openGiftCatalog();
        // Set up handler for wheel gift selection
        wheelGiftSelectionMode = true;
      });
    }
    
    // Handle gift triggers removal (event delegation)
    const wheelGiftTriggersContainer = document.getElementById('wheel-gift-triggers-container');
    if (wheelGiftTriggersContainer) {
      wheelGiftTriggersContainer.addEventListener('click', async (e) => {
        if (e.target.classList.contains('wheel-remove-gift-trigger')) {
          const giftKey = e.target.dataset.gift;
          if (confirm(`Geschenk "${giftKey}" wirklich entfernen?`)) {
            delete wheelConfig.giftTriggers[giftKey];
            
            try {
              await fetch('/api/game-engine/wheel/gift-triggers', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ giftTriggers: wheelConfig.giftTriggers, wheelId: currentWheelId })
              });
              
              renderWheelGiftTriggers();
              showMessage('Geschenk-Trigger entfernt');
            } catch (error) {
              showMessage('Fehler beim Entfernen', 'error');
            }
          }
        }
      });
    }
    
    // Handle prize payment, edit, and delete buttons (event delegation)
    const wheelWinsTableBody = document.getElementById('wheel-wins-table-body');
    if (wheelWinsTableBody) {
      wheelWinsTableBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('wheel-pay-btn')) {
          const winId = e.target.dataset.winId;
          if (confirm('Gewinn als ausgezahlt markieren?')) {
            markPrizeAsPaid(winId);
          }
        } else if (e.target.classList.contains('wheel-edit-btn')) {
          const winId = e.target.dataset.winId;
          const prize = e.target.dataset.prize;
          editWheelWin(winId, prize);
        } else if (e.target.classList.contains('wheel-delete-btn')) {
          const winId = e.target.dataset.winId;
          deleteWheelWin(winId);
        }
      });
    }
    
    // Reset all wins button
    const resetAllWinsBtn = document.getElementById('resetAllWinsBtn');
    if (resetAllWinsBtn) {
      resetAllWinsBtn.addEventListener('click', resetAllWheelWins);
    }
    
    const showUnpaidWinsBtn = document.getElementById('showUnpaidWinsBtn');
    if (showUnpaidWinsBtn) {
      showUnpaidWinsBtn.addEventListener('click', () => loadWheelWinsLog(true));
    }
    
    const showAllWinsBtn = document.getElementById('showAllWinsBtn');
    if (showAllWinsBtn) {
      showAllWinsBtn.addEventListener('click', () => loadWheelWinsLog(false));
    }
    
    const triggerTestSpinBtn = document.getElementById('triggerTestSpinBtn');
    if (triggerTestSpinBtn) {
      triggerTestSpinBtn.addEventListener('click', triggerTestSpin);
    }
    
    const btnCopyWheelOverlay = document.getElementById('btn-copy-wheel-overlay');
    if (btnCopyWheelOverlay) {
      btnCopyWheelOverlay.addEventListener('click', () => {
        const urlEl = document.getElementById('wheel-overlay-url');
        if (urlEl) {
          navigator.clipboard.writeText(urlEl.value);
          showMessage('Gl√ºcksrad Overlay URL kopiert!');
        }
      });
    }
    
    const btnPreviewWheelOverlay = document.getElementById('btn-preview-wheel-overlay');
    if (btnPreviewWheelOverlay) {
      btnPreviewWheelOverlay.addEventListener('click', () => {
        const urlEl = document.getElementById('wheel-overlay-url');
        if (urlEl) {
          window.open(urlEl.value, '_blank');
        }
      });
    }
    
    const wheelSoundVolume = document.getElementById('wheel-sound-volume');
    if (wheelSoundVolume) {
      wheelSoundVolume.addEventListener('input', (e) => {
        const volume = Math.round(e.target.value * 100);
        const volumeDisplay = document.getElementById('wheel-volume-display');
        if (volumeDisplay) {
          volumeDisplay.textContent = volume + '%';
        }
      });
    }
    
    // ========== WHEEL CUSTOM AUDIO UPLOAD ==========
    
    // Audio preview elements (created dynamically)
    let audioPreviewElement = null;
    
    // Function to upload audio file
    async function uploadWheelAudio(file, audioType) {
      if (!currentWheelId) {
        showMessage('Kein Wheel ausgew√§hlt', 'error');
        return false;
      }
      
      const formData = new FormData();
      formData.append('audio', file);
      formData.append('audioType', audioType);
      formData.append('wheelId', currentWheelId);
      
      try {
        const res = await fetch('/api/game-engine/wheel/audio/upload', {
          method: 'POST',
          body: formData
        });
        
        const data = await res.json();
        if (data.success) {
          showMessage(`Audio "${audioType}" erfolgreich hochgeladen!`);
          updateAudioStatus(audioType, file.name, true);
          return true;
        } else {
          showMessage(`Fehler: ${data.error}`, 'error');
          return false;
        }
      } catch (error) {
        showMessage(`Upload-Fehler: ${error.message}`, 'error');
        return false;
      }
    }
    
    // Function to reset audio to default
    async function resetWheelAudio(audioType) {
      if (!currentWheelId) {
        showMessage('Kein Wheel ausgew√§hlt', 'error');
        return;
      }
      
      try {
        const res = await fetch('/api/game-engine/wheel/audio/reset', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ audioType, wheelId: currentWheelId })
        });
        
        const data = await res.json();
        if (data.success) {
          showMessage(`Audio "${audioType}" auf Standard zur√ºckgesetzt`);
          updateAudioStatus(audioType, null, false);
          // Clear file input
          const inputId = `wheel-audio-${audioType}`;
          const input = document.getElementById(inputId);
          if (input) input.value = '';
        } else {
          showMessage(`Fehler: ${data.error}`, 'error');
        }
      } catch (error) {
        showMessage(`Fehler: ${error.message}`, 'error');
      }
    }
    
    // Function to preview audio
    function previewWheelAudio(audioType) {
      // Stop any currently playing audio
      if (audioPreviewElement) {
        audioPreviewElement.pause();
        audioPreviewElement = null;
      }
      
      const defaultUrls = {
        'spinning': '/game-engine/sounds/wheel/spinning sound.mp3',
        'prize1': '/game-engine/sounds/wheel/price 1 audio.mp3',
        'prize2': '/game-engine/sounds/wheel/price 2 audio.mp3',
        'prize3': '/game-engine/sounds/wheel/price 3 audio.mp3',
        'lost': '/game-engine/sounds/wheel/lost.mp3'
      };
      
      // Get the audio URL - try custom first, then default
      const customUrl = `/game-engine/sounds/wheel/custom/${currentWheelId}/${audioType}.mp3?t=${Date.now()}`;
      const defaultUrl = defaultUrls[audioType];
      const volume = parseFloat(document.getElementById('wheel-sound-volume').value) || 0.7;
      
      // Create audio element for custom audio
      const audio = new Audio();
      audio.volume = volume;
      let usingDefault = false;
      
      // Set up error handler before setting src (one-time fallback to default)
      audio.onerror = () => {
        if (!usingDefault) {
          usingDefault = true;
          audio.src = defaultUrl;
          audio.play().catch(() => showMessage('Audio konnte nicht abgespielt werden', 'error'));
        } else {
          showMessage('Audio konnte nicht abgespielt werden', 'error');
        }
      };
      
      audio.src = customUrl;
      audio.play().catch(() => {
        // Try default if custom fails to play
        if (!usingDefault) {
          usingDefault = true;
          audio.src = defaultUrl;
          audio.play().catch(() => showMessage('Audio konnte nicht abgespielt werden', 'error'));
        }
      });
      
      audioPreviewElement = audio;
    }
    
    // Function to update audio status display
    function updateAudioStatus(audioType, filename, isCustom) {
      const statusEl = document.getElementById(`wheel-audio-${audioType}-status`);
      if (!statusEl) return;
      
      const defaultNames = {
        'spinning': 'spinning sound.mp3',
        'prize1': 'price 1 audio.mp3',
        'prize2': 'price 2 audio.mp3',
        'prize3': 'price 3 audio.mp3',
        'lost': 'lost.mp3'
      };
      
      if (isCustom && filename) {
        statusEl.textContent = `Custom: ${filename}`;
        statusEl.style.color = '#2196F3';
      } else {
        statusEl.textContent = `Standard: ${defaultNames[audioType]}`;
        statusEl.style.color = '#4CAF50';
      }
    }
    
    // Load audio settings for current wheel
    async function loadWheelAudioSettings() {
      if (!currentWheelId) return;
      
      try {
        const res = await fetch(`/api/game-engine/wheel/audio/settings?wheelId=${currentWheelId}`);
        const data = await res.json();
        
        const audioTypes = ['spinning', 'prize1', 'prize2', 'prize3', 'lost'];
        audioTypes.forEach(type => {
          const setting = data[type];
          updateAudioStatus(type, setting?.filename || null, setting?.isCustom || false);
        });
      } catch (error) {
        console.error('Error loading audio settings:', error);
      }
    }
    
    // Audio file change handlers
    const audioTypes = ['spinning', 'prize1', 'prize2', 'prize3', 'lost'];
    audioTypes.forEach(type => {
      // File input change
      document.getElementById(`wheel-audio-${type}`)?.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          await uploadWheelAudio(file, type);
        }
      });
      
      // Preview button
      document.getElementById(`wheel-audio-${type}-preview`)?.addEventListener('click', () => {
        previewWheelAudio(type);
      });
      
      // Reset button
      document.getElementById(`wheel-audio-${type}-reset`)?.addEventListener('click', () => {
        resetWheelAudio(type);
      });
    });
    
    // Load Wheel config and stats on page load
    loadAllWheels();
    loadWheelStats();
    loadWheelWinsLog();

    // Handler for wheel gift selection from catalog
    async function handleWheelGiftSelection(gift) {
      if (!currentWheelId) {
        showMessage('Kein Wheel ausgew√§hlt', 'error');
        wheelGiftSelectionMode = false;
        closeGiftCatalog();
        return;
      }
      
      if (!wheelConfig.giftTriggers) wheelConfig.giftTriggers = {};
      const giftKey = String(gift.id);
      wheelConfig.giftTriggers[giftKey] = { enabled: true, name: gift.name };
      
      try {
        await fetch('/api/game-engine/wheel/gift-triggers', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ giftTriggers: wheelConfig.giftTriggers, wheelId: currentWheelId })
        });
        
        renderWheelGiftTriggers();
        showMessage(`Geschenk "${gift.name}" zum Wheel "${wheelConfig.name}" hinzugef√ºgt`);
      } catch (error) {
        showMessage('Fehler beim Speichern', 'error');
      }
      
      wheelGiftSelectionMode = false;
      closeGiftCatalog();
    }
    
    // Override click handler on gift grid when in wheel mode
    document.getElementById('gift-grid')?.addEventListener('click', async (e) => {
      const giftCard = e.target.closest('.gift-card');
      if (giftCard && wheelGiftSelectionMode) {
        e.stopPropagation();
        const gift = {
          id: giftCard.dataset.giftId,
          name: giftCard.dataset.giftName
        };
        await handleWheelGiftSelection(gift);
      }
    }, true); // Use capture phase to intercept before original handler
  </script>
</body>
</html>
